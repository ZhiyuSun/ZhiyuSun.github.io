<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计原则与生活.md]]></title>
    <url>%2F2020%2F09%2F29%2F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E7%94%9F%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[在面向对象程序设计领域，有5条非常重要的设计原则，它们的首字母拼起来，正好是S.O.L.I.D这个单词，因此也称SOLID原则。SOLID原则能够指导程序员有效避免代码中的坏味道，从而开发出易于维护和可扩展的软件。 然而SOLID原则比较难以理解，包括我自己也常常会记不全，我特别希望能把技术去应用到生活里，通过与生活的结合，去从新的维度思考技术发展的本质。因此我尝试把设计原则结合生活实际，把它们重新阐述一遍。 S——单一职责原则，Single-responsiblity principle从代码角度来讲，一个类只能承担一个职责。通俗点儿说就是一个类只能承担一件事，并且只能有一个潜在的原因去更改这个类，否则就违反了单一职责原则。 例如，筷子是用来吃饭的，勺子是用来喝汤的，刀叉是用来吃西餐的，从来没有一样厨具可以把所有的功能兼容包并，即便有那样的厨具存在，对于使用成本来说也太大了。 无论是在编程，还是在其他领域，都主张一件事物只做一件事情，只有把职责划分的足够细，功能才会明晰。 从工作角度来说，因为分工产生了协作，因协作而提升了效率，每个人都要明确自己的职责，以防在协作的过程中含糊不清，增加讨论交流的成本。 也许你会说，手机既可以拍照，也可以打电话，也可以玩各种app，它能做很多件事情，是否违反了单一职责原则？其实不然，手机是一个上层的系统，而构成手机的无数个组件都是按照单一职责来划分的。单一职责看的是局部，而不是整体。 O ——开闭原则， Open-closed principle软件实体应该对扩展开放，对修改关闭。允许扩展行为而无需修改源代码。 说回手机的例子，我们之所以能够在手机上下载各式各样的应用，其实就跟开闭原则有关。手机提供了一个平台，为各类app提供了很多的基础能力，而各个app按照自己的应用场景去定制开发，然后使用者使用安装app的形式，去获得这部分的功能。因此对手机来说，它本身的修改是关闭的，但是对功能的扩展是开放的。 试想，如果手机违反了开闭原则，则每次想要获得新功能，都要首先升级手机自身的程序，安装app就会变得特别繁琐。 再比如，吹风机可以搭配不同风格的出风口，充电器可以搭配不同型号的充电线，这些都是很好的开闭原则的例子。 我觉得开闭原则对我们人生也有很多启示，如果我们自己能够形成一以贯之的人生方法论，不用每次获取新知识时都把自己推翻和重建，是不是在获取新知的过程中效率更高了呢？ L——里氏替换原则，Liskov substitution principle程序中的对象应该可以被其子类实例替换掉，而不会影响程序的正确性。 例如做菜的时候，你可能要放食用油，但是油分为好多种，比如大豆油，橄榄油，花生油，菜籽油等等，这些品种都是食用油的子类，每一种都可以进行替代。 谈到替换两个字，我不禁想到了作为程序员，很容易被更年年轻的程序员替换，如果一个程序员只是满足于当下的工作，完全按照既定的父类的框框去做事情，不注重技术的创新和知识的迭代，那往往就会被更多的新的子类程序员替换掉。 所以代码要遵从里式替换，但是职业发展拒绝被里式替换。 在编程开发中，往往只要代码符合了里式替换原则，也很难不符合开闭原则，对于不符合里式替换原则的场景，又可以借助下面的接口隔离原则来实现。 I ——接口隔离原则，Interface segregation principle使用多个特定细分的接口比单一的总接口要好，不能强迫用户去依赖他们用不到的接口。 举个简单的例子，麻雀，燕子，鸽子，鸵鸟都是鸟，但是鸵鸟不会飞，对于会飞这个属性来说，就不能独属于鸟，而应作为鸟类的一个接口。 接口隔离原则也体现了继承和组合的区别，如果是继承，继承使得父类暴露了过多细节给子类，也使得父类难以改变，而组合则更加灵活，是一种更方便的扩展手段。 扯远一点说，接口隔离原则是承认了世界的复杂性。没有一项事物是我们能够用单一标准所评价的。 D ——依赖倒置原则，Dependency Inversion Principle程序要依赖于抽象接口，而不是具体实现。高层模块不应该依赖于低层模块，二者都应该依赖于抽象抽象不应该依赖具体实现，具体实现应该依赖抽象 简单来讲，实现依赖抽象，存在一个总的原则在指导我们，而具体的实现细节可以自由把控。 比如做一道炒菜，你可能需要买菜、备菜、炒菜、出锅等必要工序，具体去那里买，具体怎么切菜，用什么锅炒菜都可以自由发挥，但是整体的做菜过程是千篇一律的。 再比如，我们每个人从出生，到上学，到工作，到成家立业，也是在一个大的框架体系下进行的，这种框架类似于某种社会共识，而每个人都是这个社会共识的具体实现，如果没有了这个框架，个体自由度过大，则会加剧社会的维护成本。 能否灵活运用依赖倒置原则，也是判断一个程序员是否资深的重要标准。高水平的程序员应该用框架来指导开发，而不是拘泥于细节，编程领域的很多框架，例如spring,tomcat都运用了依赖倒置思想。 以上5点设计原则对于编程设计来说，尤为重要。对于已经有一定经验的程序员，在日常工作开发中，一定要对自己的要求更高一层，而设计原则能够指导代码往增强可测试性和更易于维护的方向转变，是非常不错的优化方向。]]></content>
      <categories>
        <category>比特胶囊</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊一聊程序员职业(2021版)]]></title>
    <url>%2F2020%2F06%2F08%2F%E8%81%8A%E4%B8%80%E8%81%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E8%81%8C%E4%B8%9A(2021%E7%89%88)%2F</url>
    <content type="text"><![CDATA[在《聊一聊程序职业(2019版)》里，我粗略介绍了一下我对程序员职业的认知。有经历过两年的沉淀，再加上市场环境的变化，我现在对这个行业的认知更加丰富而深刻了，分享下我的见解。 迷茫的开始对于刚毕业工作1-3年的程序员，由于经验不丰富，干什么都觉得特别新鲜，很有干劲，这段时间也能得到快速的成长。可是3年之后，他就会发现，似乎公司里做的东西都得心应手了，每天更多的是在重复劳动，进入了舒适区。再加上精力上也比不上公司的新人了，年纪大了也要面临35岁危机，于是他便开始陷入迷茫。 其实这是正常现象，如果你没有很长远的目标，或者习惯随波逐流，很容易不知所措。 职业生涯早期，我们有明确的目标，工作内容主要是完成手上的任务，工作模式比较单一，等到工作资历渐长，无论是我们自己，还是这个行业，都不会允许我们裹足不前，这就需要我们开始觉醒。 叔本华说，人生就是一团欲望，欲望不能满足便痛苦，满足了便无聊，人生就在痛苦和无聊之间摇摆。 所以人生其实是螺旋式上升的，我们能感受到自己的迷茫是好事，至少此时你已经发现了问题。这时候就要采用积极的行动去解决问题。毕竟程序员的本质就是去解决问题。 内卷与焦虑谈完了个人，接下来我们来看看外面的世界。今年关于“内卷”的讨论特别火，由于僧多粥少，程序员行业的竞争也变成存量竞争，大家的竞争愈发激烈，行业门槛也越来越高。 当行业红利消散，便到了理性思考的时候，无论是行业还是个人，都应该去多考虑一些更长远的事情。 社交网络在大肆渲染着焦虑，我们太容易被程序员高薪表象所吸引，进大厂拿高薪似乎也成了每个程序员的唯一归宿，大家为了这个目标开始了疯狂的行动，每个人活得很累也成了必然结果，这个社会也越来越卷。 这个时代，焦虑已无法避免，作为程序员，是时候该要思考如何破局了。 破局之道身处内卷的浪潮之中，我在最近一两年也在不断思考，如何成为一个更加厉害的程序员，提高自己的竞争力，让自身更有价值。我从个人经历角度，总结了以下五点，欢迎讨论交流： 1. 打好基础我不是科班出身的程序员，在职业道路上踩了很多坑，走了很多弯路，这些都是我血泪的教训。曾经的我只是满足于完成工作任务，但是现在的我明白了越高级的程序员，绝不只是完成任务那么简单，更需要很广博的知识和很深厚的功底，方能支撑去做好系统架构。 而对计算机基础知识的掌握深厚程度，很大程度上决定了一个程序员所能到达的上限。这些内容，即使是科班出身的同学，毕业几年后也会忘，更何况是非科班出身的同学呢，他们更没有理由去浪费时间，需要花别人好几倍的功夫去补足它们。 这些基础知识包括数据结构和算法、操作系统、计算机网络、编译原理、计算机体系结构等等。每一门完全掌握都要花很多功夫，需要投入大量精力。程序员是个需要终身学习的职业，必须学会享受其中。 2. 构建体系程序员所掌握的知识远不止前面提到的计算机基础，是一个浩瀚的海洋。包括Java/go/python，设计模式，并发编程，开发框架，数据库、缓存、消息队列，分布式微服务，服务治理，限流熔断降级…… 面对浩如烟海的知识，要达到高效学习，最重要的是要构建自己的知识体系。 学习上也有飞轮效应，指为了使静止的飞轮转动起来，一开始你必须使很大的力气，一圈一圈反复地推，每转一圈都很费力，但是每一圈的努力都不会白费，飞轮会转动得越来越快。 最开始构建好知识体系是难的，等到大厦的结构建成，心中有了整体的认知，后面学到的知识都是在上面添砖加瓦，反而会变得简单。 等到知识掌握到一定程度，就会发现，其实编程里面很多知识都是相通的，构建知识体系帮我们形成了结构化思考的能力，工作越来越游刃有余。 另外再说一点，很多程序员工作几年后会发现，公司里做的东西非常普通，根本不涉及我前面提到的那么多的技术。确实，这也是行业通病，面试造火箭，工作拧螺丝。但我想，每个人都是在为自己的简历打工，即便工作之中用不到这些技术，自己也要主动去学，并且主动思考能否运用到业务中。这也是高级程序员和普通程序员不同的地方。 3. 知行合一前面两点一直在讲学知识，但是学而不思则罔，真正让我们学会知识的，是要亲自去实践，去用知识。 所谓“听过很多道理，但过不好这一生”，听到的别人的经验永远不是自己的，只有通过实践总结才能真正成为自己的。 这需要我们平时在学习的过程中，不能浅尝辄止，多去思考知识的实际使用场景，并去加以应用，哪怕工作中用不上，自己也可以写一些demo，做一些开源项目等等，把自己的想法付诸实践。 此外，以教为学也是一个很好的检验自己是否掌握知识的方式，可以多尝试总结和输出，这同时也是构建知识体系的好的方式。 最后，也可以寻找一些学习社群或者技术组织，跟更多的程序员相互切磋，共同成长，避免一个人学着学着迷失了方向。 4. 志存高远我知道除了极少数的对编程抱有极大热情的程序员之外，绝大部分程序员只是希望凭着提升自己的技术进大厂，去更好的平台那更高的薪酬，学习编程更多是成了他们升职加薪的工具。 我当然不否认他们的做法，但是我也发现很多人其实对编程并不那么感兴趣，但又有进大厂的梦想，于是每天学得苦不堪言，但是靠着自身的坚持一路走到现在。 在这里我想说，只靠坚持一定走不长远，我们或许可以赋予编程更崇高的意义去引领我们行动，而不是简单的为了求职面试。比如，学习编程是为了让我们成为更好的自己，让我们去养成科学的学习方法，以及不断给自己磨炼去培养各方面的能力，让我们认识到世界的疆界和自我的局限，甚至让我们看到突破自己极限所带来的的巨大能量。 既然入了这一行，不管热爱与否，通过不断学习，让自己保持着竞争力，让自己的能力匹配上自己的资历也是匠人精神的体现。 左耳朵耗子叔曾说一句话：要应付并通过面试并不难，但是，千万不要应付你的人生，你学技术不是用来面试的，它至少来说是你谋生的技能，要尊重自己的谋生技能，说不定，哪天你还要用这些技能造福社会、改变世界的。 5. 但问好事最后，但问好事，莫问前程。 我能感受到这个时代的内卷和焦虑永远不可抑制，只会逐渐加深。现在“躺平”的呼声也很高，越来越多的人意识到工作生活平衡的重要性，抵制无节制的内卷。 对于我自己，坦然接受那些不能改变的，勇敢去做那些我能改变的，并学习去分清两者的区别。 人生没有白走的路，每一步都算数。心中有目标，行动有规划，日拱一卒，功不唐捐。 特别喜欢《传习录》里的一段话： 立志用功，如种树然。方其根芽，犹未有干；及其有干，尚未有枝；枝而后叶，叶而后花实。初种根时，只管栽培灌溉，勿作枝想，勿作叶想，勿作花想，勿作实想。悬想何益？但不忘栽培之功，怕没有枝叶花实？ 最后，祝福大家的职业之路都能一帆风顺！]]></content>
      <categories>
        <category>比特胶囊</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>编程</tag>
        <tag>职场</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DRF最佳实践的十件事]]></title>
    <url>%2F2020%2F04%2F04%2FDRF%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E7%9A%84%E5%AE%9E%E8%B7%B5%E5%8D%81%E4%BB%B6%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[讨论一下关于Django Restfule Framwork的最佳实践 翻译文章，原文地址：https://medium.com/profil-software-blog/10-things-you-need-to-know-to-effectively-use-django-rest-framework-7db7728910e0 1. ViewSetsviewsets的好处是使得你的代码保持一致，并且免于重复。如果你编写的views不止去做一件事，那么viewsets就是你想要的东西。 举例来说，如果你有一个model叫做Tag，你需要列表、创建和详情的功能，你可以定义一个viewset: 12345678910111213141516from rest_framework import mixins, permissionsfrom rest_framework.viewsets import GenericViewSetclass TagViewSet(mixins.ListModelMixin, mixins.CreateModelMixin, mixins.RetrieveModelMixin, GenericViewSet): """ The following endpoints are fully provided by mixins: * List view * Create view """ queryset = Tag.objects.all() serializer_class = TagSerializer permission_classes = (permissions.IsAuthenticated,) viewset的mixins可以被自由组合，你可以定义自己的mixins或者使用ModelViewSet。 ModelViewset可以为你提供以下方法：.list()，.retrieve(), .create(), .update(), .partial_update(), .destroy()。 此外，当你使用viewsets时，也会令你的路由配置更加的清晰。 12345678910from django.conf.urls import url, includefrom rest_framework.routers import DefaultRouterapi_router = DefaultRouter()api_router.register(r'tag', TagViewSet, 'tag')urlpatterns = [ url(r'^v1/', include(api_router.urls, namespace='v1'))] 现在，你的viewset可以帮你实现以下功能： 获取Tag列表，发送GET请求给 v1/tag/ 创建Tag，发送POST请求给 v1/tag/ 获取特定Tag，发送GET请求给v1/tag/&lt;tag_id&gt; 你甚至可以在viewset里面通过@action装饰器添加一些自定义的路由。 2. 理解不同类型的serializers作为一个DRF的使用者，你不必太去关心views或者路由配置，所以你可能会把绝大部分精力放在serializers上来。 serializers是充当Django的model及其表现形式（例如json）之间的翻译器。每一个serializer能够既被用作读也可用作写，初始化的方式决定了它将执行的动作。我们可以区分出三种不同类型的serializer: create, update, retrieve。 如果你想要在序列化器外部传输数据，下面是一个例子： 1234def retrieve(self, request, *args, **kwargs): instance = self.get_object() serializer = ProfileSerializer(instance=instance) return Response(serializer.data) 但是创建时，你需要另一种写法： 12345def create(self, request, *args, **kwargs): serializer = ProfileSerializer(data=request.data) serializer.is_valid(raise_exception=True) serializer.save() return Response(serializer.data) 最后，当你更新一个实例，你不但要提供instance，也要提供date: 123456789def update(self, request, *args, **kwargs): instance = self.get_object() serializer = ProfileSerializer( instance=instance, data=request.data ) serializer.is_valid(raise_exception=True) serializer.save() return Response(serializer.data) serializer.save()会基于初始化时的参数传递调用适当的内部方法。 3. 使用SerializerMethodFieldSerializerMethodField是一个只读的字段，通过在其附加到的serializer classs上调用相应的方法，在请求处理时计算其值。 举例来说，你有一个model，里面有一个字段datetime存储的是models.DateTimeField类型，但是你想在序列化时，获得timestamp类型的数据： 123456789101112from rest_framework import serializersclass TagSerializer(serializers.ModelSerializer): created = serializers.SerializerMethodField() class Meta: model = Tag fields = ('label', 'created') def get_created(self, obj): return round(obj.created.timestamp()) SerializerMethodField接收method_name，但是通常使用默认的命名方法会更为便捷，比如get_&lt;field_name&gt;。另外你要确保，不会为任何繁重的操作增加方法字段的负担。 4. 使用source参数很多情况下，你的model里面定义的字段，与你想要序列化的字段不一样。你可以使用source参数，轻松解决这个问题。 举个例子： 1234567from rest_framework import serializersclass TaskSerializer(serializers.ModelSerializer): job_type = serializers.CharField(source='task_type') class Meta: model = Task fields = ('job_type',) 模型中的task_type会被转换成job_type。这个操作不光适用于读，还适用于写。 另外，你还可以借助点语法去从关联的模型中获取字段。 1owner_email = serializers.CharField(source=&apos;owner.email&apos;) 5. 序列化字段的验证除了在初始化serializer字段和serializer.validate（）hook可以传递的validators参数之外，此外还有一种字段级别的验证，可以帮你为单独的每个字段定义它们自己的验证方法。 我发现它有用的原因有两个：首先，它可以对特别的字段进行校验，进行解耦。其次，它可以产生结构化的错误响应。 这种验证方式的使用，和SerializerMethodField特别相似，只是这时候的函数名字形如def validate_&lt;field_name&gt;。举个例子： 1234567891011from rest_framework import serializersclass TransactionSerializer(serializers.ModelSerializer): bid = serializers.IntegerField() def validate_bid(self, bid: int) -&gt; int: if bid &gt; self.context[&apos;request&apos;].user.available_balance: raise serializers.ValidationError( _(&apos;Bid is greater than your balance&apos;) ) return bid 如果验证错误，会得到下面这样的输出： 123&#123; &quot;bid&quot;: [&quot;Bid is greater than your balance&quot;]&#125; 验证方法必须要返回一个值，之后会传给model实例。 另外要记住，字段级别的验证将会在serializer.validate()之前被serializer.to_internal_value()调用。 6. 把值直接传给save方法某些情况下，将值从序列化器外部直接传递到其save（）方法很方便。 此方法将采用可以等同于序列化对象的参数。以这种方式传递的值将不会得到验证。它可用于强制覆盖初始数据。 123serializer = EmailSerializer(data=request.data)serializer.is_valid(raise_exception=True)serializer.save(owner_id=request.user.id) 7. 使用CurrentUserDefault如果需要设置用户，比上面的例子更好的是，使用CurrentUserDefault，这时候不必去重写view了。 123456from rest_framework import serializersclass EmailSerializer(serializers.ModelSerializer): owner = serializers.HiddenField( default=serializers.CurrentUserDefault() ) 这将会做两件事。首先，将在请求对象中认证的用户设置为默认用户。其次，因为使用了HiddenField，因此不会考虑任何传入的数据，所以不可能会设置成别的用户。 8. serializers的初始数据有时候你需要去获取serializer的最原始的数据。这是因为数据已经通过运行serializer.is_valid（）进行了修改，或者需要在validated_data尚不可用时比较验证方法中另一个字段的值。 数据能够通过serializer.initial_data被获取到，格式是dict，举个例子： 123456789101112from rest_framework import serializersclass SignupSerializer(serializers.ModelSerializer): password1 = serializers.CharField() password2 = serializers.CharField() def validate_password1(self, password1): if password1 != self.initial_data['password2']: raise serializers.ValidationError( 'Passwords do not match' ) 9. 在嵌套序列化程序中处理多个创建/更新/删除大多数时候，序列化器是完全简单的，并且有一定的经验，没有什么可能出错。但是，有一些限制。当您必须在一个高级序列化程序中支持嵌套序列化程序中的多个创建，更新和删除操作时，事情可能会有些棘手。 这需要权衡：要选择处理较多的请求数量，还是在一个请求里处理较长的时间。 默认情况下，DRF根本不支持多个更新。很难想象它如何支持所有可能的嵌套插入和删除类型。这就是DRF的创建者选择灵活性而非现成的“万能”解决方案的原因，并把特权留给了我们。 在这种情况下，可以遵循两种路径： 使用颇受欢迎的第三方库DRF Writable Nested 自己做 我建议至少选择一次第二个选项，这样您就会知道其中的含义。 在分析传入数据之后，在大多数情况下，我们可以做出以下假设： 所有应更新的实例都有ID， 所有应创建的实例都没有ID， 所有应删除的实例都都存在于数据存储（例如数据库）中，但不会出现在传入的request.data中。 基于此，我们知道如何处理列表中的特定实例。以下是详细显示此过程的代码段： 1234567891011121314151617181920212223242526272829303132333435363738394041424344class CUDNestedMixin(object): @staticmethod def cud_nested(queryset: QuerySet, data: List[Dict], serializer: Type[Serializer], context: Dict): """ Logic for handling multiple updates, creates and deletes on nested resources. :param queryset: queryset for objects existing in DB :param data: initial data to validate passed from higher level serializer to nested serializer :param serializer: nested serializer to use :param context: context passed from higher level serializer :return: N/A """ updated_ids = list() for_create = list() for item in data: item_id = item.get('id') if item_id: instance = queryset.get(id=item_id) update_serializer = serializer( instance=instance, data=item, context=context ) update_serializer.is_valid(raise_exception=True) update_serializer.save() updated_ids.append(instance.id) else: for_create.append(item) delete_queryset = queryset.exclude(id__in=updated_ids) delete_queryset.delete() create_serializer = serializer( data=for_create, many=True, context=context ) create_serializer.is_valid(raise_exception=True) create_serializer.save() 这是高级序列化程序如何利用此mixin的简化版本： 12345678910111213141516171819202122from rest_framework import serializersclass AccountSerializer(serializers.ModelSerializer, CUDNestedMixin): phone_numbers = PhoneSerializer( many=True, source='phone_set', ) class Meta: model = User fields = ('first_name', 'last_name', 'phone_numbers') def update(self, instance, validated_data): self.cud_nested( queryset=instance.phone_set.all(), data=self.initial_data['phone_numbers'], serializer=PhoneSerializer, context=self.context ) ... return instance 请记住，嵌套对象应使用initial_data而不是validated_data。 那是因为运行验证会在序列化器的每个字段上调用field.to_internal_value（），这可能会修改特定字段存储的数据（例如，通过将主键更改为模型实例）。 10. 覆盖数据以强制排序通过在view上的queryset添加排序，可以轻松地实现对列表视图的排序，但是在还应该对嵌套资源进行排序的情况下，并不是那么简单。 对于只读字段，可以在SerializerMethodField中完成，但是在必须写字段的情况下该怎么办？ 在这种情况下，可以覆盖序列化程序的data属性，如以下示例所示： 12345@propertydef data(self): data = super().data data['phone_numbers'].sort(key=lambda p: p['id']) return data 结论：希望您在本文中找到了一些有趣的新技术。有新的drf使用技巧或想法，欢迎分享！]]></content>
      <categories>
        <category>比特胶囊</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>翻译</tag>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5000字干货总结python社招面试经验]]></title>
    <url>%2F2019%2F12%2F04%2F5000%E5%AD%97%E5%B9%B2%E8%B4%A7%E6%80%BB%E7%BB%93python%E7%A4%BE%E6%8B%9B%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[即使是临近年末，我依然选择了裸辞，冒着可能会失业的风险。 花了一周多一点的时间，在上海参加了十几家公司的面试，也包括美团、字节跳动等大厂，可是因为能力不够或技术栈不匹配被刷了。最终有三四家想要要我，我也拿到了一份较为满意的offer。 我工作三年，主要编程语言是python，找的是后端开发或运维开发的岗位，想结合自己的实际面试经历，来谈一谈python社招的一些经验，欢迎大家交流讨论~ 即使是临近年末，我依然选择了裸辞，冒着可能会失业的风险。 我之前是在深圳工作的，因为自己是江苏人，也不想在深圳长期发展，所以先辞了职，回到上海这边好让自己更方便的参加面试。 这是我第二次裸辞了，有了上一次的裸辞经验，我这一次在心理准备方面，明显更加的游刃有余。 花了一周多一点的时间，在上海参加了十几家公司的面试，也包括美团、字节跳动等大厂，可是因为能力不够或技术栈不匹配被刷了。最终有三四家想要要我，我也拿到了一份较为满意的offer。 面试是一个非常消耗心力的过程，我很难想象，若不是我比较侥幸，拿到了几个还满意的offer，我很难想象在此时凄风苦雨的寒冷的上海，孑然一身的我，会面临怎样的崩溃与绝望。 所以，我衷心希望，我能够把自己的一些面试经验分享出来，去帮助到一些正在找工作的朋友，让他们的求职之路更顺利一些，少一点像我这样的折腾。 我工作三年，主要编程语言是python，找的是后端开发或运维开发的岗位，想结合自己的实际面试经历，来谈一谈python社招的一些经验，欢迎大家交流讨论~ 面试之前市场环境 先说一下大环境，中国的互联网环境已经渐趋稳定成熟了，但初中级别的程序员依然很泛滥，高级程序员很缺失。所以想要在众多应聘者中脱颖而出，实力才是王道。 另外，通常的招聘季是金三银四或者金九银十，像我这个11月份去找工作的毕竟是很少了，但我觉得上海毕竟是大城市，要说市场上没有岗位是不可能的，另外在淡季，和我竞争的人也很少了。所以，基于以上的判断以及自己的勇气，我毅然觉得辞职，从深圳来到了上海。 个人定位 我觉得，每一个招聘者都要对自己在市场上的位置做一个合理的评估，这样才能准确的知道自己想要找什么类型的公司，是大公司大平台呢，还是中小型企业呢，还是创业公司呢？评估的依据，取决于自己的实力，职业道路的方向，以及对市场的认识。 不过如果不清楚也没有关系，投递公司的时候可以各类公司都投一投，大中小公司都去面一面，总之，不要把鸡蛋放在一个篮子里，多给自己制造一些机会。面试是一个很好的去接触外界，了解自己能力水平的过程，可以帮助你对市场环境有一个更清晰的认识。面试结束后通常有反问问题的环节，也可以把握住机会，多去问一问对方公司在做的东西，使用的技术栈等等。 对于我自己来说，我就把面试当成一个很好的检验自己的机会，同时让我有机会去和别的公司交流技术。所以说，平时在工作过程中，也可以隔三差五的出去面试一下，看看自己的能力水平几何，避免自己和市场脱节太久，以及温水煮青蛙的情况。 简历 接下来就是制作一份简历，关于如何制作一份简历，网络上的教程也很多了。我觉得技术简历的关键就是要把自己的做的比较出彩的项目，以及个人技术栈讲清楚，这些都是面试中问的比较频繁的几个点。另外因为自己痴迷于markdown，第一次尝试了markdown风格的简历，效果还不错，蛮清晰的。 渠道 对于招聘渠道的选择，如果有小伙伴的内推那是最好的，另外建议多注册几个app，多管齐下的去寻找面试机会，比如拉勾、boss直聘、猎聘等等。一些想去的公司的官网的招聘页，也是一个不错的信息来源。 面试准备作为技术面试，该如何去复习准备面试呢，我觉得可以从以下几点去考虑。 数据结构与算法 为什么把这一块放在第一个讲，因为这是技术面试里非常重要，但是平时工作中又最容易忽视的一块。都说「面试造航母，工作拧螺丝」，如果不是算法岗，程序员在日常工作中算法使用场景非常有限，但这就是面试考察的一个重点。 我大概面了十几家公司，基本每家公司都会考一些算法题，或者让你说一下思路，或者直接手写程序，如果没有事先准备过，会特别的不适应，尤其是白板算法那块。 所以，我的准备建议是，面试前至少前一周，就要花时间去练习算法题，保持手感了。 首先强推leetcode网站，中文站是https://leetcode-cn.com/。leetcode是非常有名的刷题网站，里面汇聚了各大企业的经典算法题，而且可以在线提交代码，自定义测试用例，查看其他人的题解等等。如果你觉得中文站上面的题解没有自己想要的，也可以看一下外文站https://leetcode.com/，他们的题目顺序都是一样的，只是中文站在本土化这方面更强一点。 如果因为时间紧迫，我建议你针对以下数据结构和算法的知识点进行重点复习： 各种排序算法，冒泡排序，堆排序，快速排序等，时间复杂度空间复杂度分析，能做到手写。 常用数据结构。链表、二叉树、堆、栈等等。 经典算法题。（待整理） 基础知识 任何一门技术面试，基础知识一定是重中之重。对于python程序员面试来说，我觉得下面三块内容比较重要，考察的频率也非常高。 语言基础 可变对象、不可变对象、装饰器、迭代器和生成器、线程和进程、魔术方法、动态解释性、元类等。 web基础 http请求、状态码、网络安全、django处理请求的顺序、cookie和session 数据库 mysql的事务、索引、锁、性能调优，nosql数据库中redis考察的比较多。 项目经验 一般对应届生来说，基础知识很重要。对于社招来说，项目经验是非常重要的一块内容。 我建议可以从下面几个角度去准备自己的项目： 项目介绍 推荐STAR模型。 S——situation，项目是什么背景下产生的T——task，你的任务是什么A——action，你怎么做的R——result，结果如何 项目中的难点、闪光点 我相信每一个真实做过自己的项目的人，肯定会对自己的项目有所思考。总结一下自己在这个项目里最难的地方，以及最精彩的地方，也可以使用上面的STAR模型。 项目框架 有的面试官会要求你在白纸上把项目的框架图或者设计图画出来，这个也可以提前准备下，做到条理清晰，临场画的话很容易乱。 总结 面试是一场艰难的战役，我发现在那种紧张对弈的交锋氛围中，我从来没有体会过所谓超常发挥的感觉，准备了100分，能把60分发挥出来就已经非常不错了。所以，建议每一个面试者都要提前把一些必问的东西（个人介绍、项目经验等等）提前准备好，并且模拟表达一下，以防临场紧张而忘词。 面试真题因为自己大厂和创业公司都会去面，给我的感觉是，大厂的考察深度会更深一点，比如问你怎么用python定位一些内存满、CPU满的问题，怎么做mysql性能优化等等。而小公司问的更多是一些基础问题，以及看你之前经验的一个匹配度。 我这里从我亲身的面试经历，精选出了30道面试常考题，涉及到了python面试的方方面面，大家可以自行测试。 python基础 python是什么样的语言，和其他语言的区别。 python中的线程和进程，以及使用场景，你知道协程吗？ GIL是什么，为什么会有GIL，去掉会怎样，有了GIL为什么还要给程序加锁？ 迭代器、可迭代对象、生成器分别是什么？生成器的作用和使用场景？ python中的装饰器是什么？如何实现？使用场景？ python中的元类是什么？ python中的可变对象和不可变对象之间的区别。 python的魔术方法你知道哪些，new，init，call的区别是什么 django的中间件是什么 celery的原理，如何配置worker的权重 项目 如何定位内存过高或CPU过高的问题 画一下你的项目的结构 项目中你遇到的最大的困难是什么，是如何解决的？ 项目中你最有成就感的地方是什么？ 你业余是怎么学习编程的？看哪些书？有自己做过什么项目？ web HTTP/GET/POST/PUT/PATCH之间的区别 状态码的含义以及出现场景，301，302，404，500，502，504等 cookie和session的区别和联系 从url请求到返回，中间经历了什么 HTTP和HTTPS的区别，HTTPS如何进行加密的 数据库 mysql的索引是什么，如何建立索引，B+树的结构 mysql中的事务是什么，隔离等级是什么 如何优化sql语句 mysql的性能优化等 操作系统 堆和栈的区别 什么是io多路复用 nginx的配置 算法 找到整数列表的最大k个数，时间复杂度 输入一维数组array和n，找出和值为n的任意两个元素 常见的排序算法，时间复杂度分析 生成一个旋转矩阵 职业发展作为一个代码打工仔，对于我来说，想要成为牛逼的程序员的路还很长，一刻都不能懈怠。 我无法从HR角度，或者技术leader的角度来臆测哪种状态的面试更能获取面试官青睐。但通过我积攒的大量的面试经验，我多少可以推断一些成为有竞争力的程序员的一些必要条件。 1. 技术是王道 这一点毋庸置疑。我是一个非科班出身的程序员，在技术成长方面更多的是在工作中学，但这还远远不够，每一位想要成为大牛的程序员，都必须深入底层原理去学习，比如操作系统、网络、数据结构和算法等，也许这些东西在你工作中看起来没用，却是提高你的技术深度，扩大技术视野的非常重要的一环。 我是一个比较容易自卑的人，在面试的时候，遇到答不上来的问题还是非常容易挫败的，觉得自己好弱。术业有专攻是一方面，但很多基础的东西是一个程序员的基本素养，在这上面丢分还是很容易给面试官造成一个不好的印象的。另外，面试所覆盖的点也不一定完全击中你所准备的东西，我觉得面试者可以在面试过程中主动「推销」自己，哪怕一个问题没答上来，也要尽可能的展现一下自己在这一块内容里做过哪些研究，避免面试官错误预估你的水平。 除了基础知识和底层原理，技术的另一块内容就是你在工作中的实践了。我在工作中常常见到一类人，他们只满足于被分配的任务，抱着多一事不如少一事的观念，不去把一个问题深入的去弄明白，害怕技术挑战，包括我自己曾经也是这一类人。 其实这样对职业发展的道路是非常不好的，如果不去走出舒适区，你永远只是一个CURD的程序员，完全没有市场竞争力。在面试中最能展现自己的，就是你在面对技术难题的时候，是如何研究，如何思考，如何解决的。所以，工作中遇到技术难题，一定要把它当做技术上的试金石，成长的宝贵的机会，而不要当做拦路虎而逃避。 2. 工作经历 面试官常会问的一个问题是，你未来的职业规划是什么。我不知道其他人有没有清晰的规划，对我自己来讲，更多的还是走一步看一步，并没有想的特别远，这其实是很不好的。 曾经有一个面试官对我讲，5年是一个关键节点，如果你工作5年，依然没有华丽的工作履历，或者工作能力仍旧处于小白水平的话，是非常危险的，市场对你的能力是由怀疑的。 我想，如果作为一个5年开发经验的人，他差不多也换了两三份工作了吧，从每一个公司的情况每一个工作岗位的内容，多少可以看出点他的职业发展路径有没有一条清晰的路线。如果一个人的目标很明确，他的每次跳槽一定有自己的内在逻辑在里面，他的技术成长也不会太差。而如果每次跳槽都很盲目，技术成长没有延续性，很可能你虽然工作很多年，但是根本没有核心的技术竞争力，这是要警惕的。 对未来的规划这块内容，我自己也非常欠缺，因为我总是抱着要「活出自我」的想法，对一些世俗理论天然排斥，其实是走了很多弯路的，不过既然我意识到了这一点，亡羊补牢为时未晚吧，未来，会多接触一些技术大牛，参加一些技术论坛，不会囿于自己的舒适区，早点找到一条快速的职业发展路径。 薛兆丰老师曾经讲过一句话，「每个人都在为自己的简历打工」，我在这里感同身受，卖方只是提供工作岗位的，竞争永远是买方和买方之间的竞争。所以，想要出人头地，一定要比其他员工多下功夫，少壮不努力，老大徒伤悲。 3. 格局 这个词是我从一个猎头朋友那儿听到的，他说在职场中，男生最重要的是格局。 我是这么理解的，只有你愿意到达什么样的高度，你才有可能成为什么样的高度的人。比如，如果你只甘心做一个工程师，那就活该当一个底层码农了，而如果你能够站在更高的维度去做一些事情，我相信你能收获很多宝贵的东西。 比如，在实际开发中，多去把一些业内的新技术引用进来，而不是仅仅满足于已经成熟的开发框架；不再仅仅去完成领导分配的任务，多站在公司或者团队的视角去看问题，多一些全局的视野；遇到问题时，不要简简单单的解决了就完事了，要学会深入底层，以及触类旁通，把这一类问题都解决，形成自己的思考问题的逻辑框架…… 这些东西也是我在此前的工作中缺失的，我希望我自己能够在新的工作中，多思考，多沉淀，形成自己的技术格局。 毕竟也不是初入职场的小白了，我理当给自己提出更高的要求，这也是为了在下一次的招聘过程中，能更顺利一些。 每次拿到offer之后，总会长舒一口气，觉得自己可以休息一下了。但随之而来的是，后面的入职、适应新的工作、新的工作团队，搬家找房，一个又一个的挑战接踵而至。 还不能懈怠啊，希望自己在二十一世纪一十年代能安稳下来，以最好的姿态去迎接2020年！也祝所有在找工作的朋友们早日拿到满意的offer。 最后，我建了一个github的项目，上面会持续更新我的python学习心得和面试指导，欢迎star~ https://github.com/ZhiyuSun/python-interview]]></content>
      <categories>
        <category>比特胶囊</category>
      </categories>
      <tags>
        <tag>职场</tag>
        <tag>面试</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊一聊程序员职业]]></title>
    <url>%2F2019%2F11%2F13%2F%E8%81%8A%E4%B8%80%E8%81%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E8%81%8C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[最近公司来了一批新人，特别有干劲，学东西也快。作为一个有着三年开发经验，25岁「高龄」的程序员，看着这些95后们逐渐登上历史舞台，不免产生了一种危机感。。。 最近公司来了一批新人，特别有干劲，学东西也快。作为一个有着三年开发经验，25岁「高龄」的程序员，看着这些95后们逐渐登上历史舞台，不免产生了一种危机感。 我常常想，和这些新人相比，我的优势在哪儿，可是思考的结果让自己很心痛。三年间我接触过后端、前端、测试、运维、产品、设计、python、web，所学博杂，但好像没有啥核心优势，总是担任着螺丝钉的角色，这样下去，我该如何保持自己的竞争力，如何去应对「35岁辞退危机」。。 虽然没有核心技术，但是我有工作经验呀，所以，想结合我三年的编程之路，从一名普通的小码农的角度，来谈一谈我对程序员这份工作的理解。本人非大牛，本文主要面向初、中级别的程序员，文章也只是一家之言，想看硬核的程序员发展之路的请绕道。 工作常识我先列举一下我对一份工作的基本观点，程序员毕竟也是一份岗位，和千千万万的岗位也一样，也拥有着一份工作的基本特征。 1. 90%的岗位都是初级岗位 网络上经常有一些对程序员的调侃，其实我们不必把程序员妖魔化，程序员本质上只是一份普通的职业而已。 所有职业都有初级、中级、高级之分，程序员也不例外。我觉得90%的岗位，一个普通人在上面呆一个月，就能熟练了。一个初级的程序员，其实并不需要很多的修炼，只要掌握一门语言20%的知识，就能应对80%的工作了。 做程序员的难点在于，你如何找到一条技术提升的路径，实现从菜鸟向高手的转型，并且加以坚持。 2. 工作的本质：出售自己的时间换取金钱 程序员为什么工资高？ 因为想要写好程序真的要投入很多时间，而且遇到项目紧急或者产品上线常常需要加班，有时候通宵也在所难免。再加上从社会的角度来看，程序员是要吃青春饭的。 从以上几点上来看，工资高就不足为奇了。 3. 凭大部分人的努力成果，还没有到拼天赋的时候 这也是一个老生常谈的话题了。 我自己有一个「地铁理论」，是我每天挤早高峰的地铁时悟到的。假设普通人平均每天的地铁通勤时间是30min，但我总能比普通人平均节省5min左右地铁时间，在列车上的通勤时间（工作时间）大家都一样，我的优势就在于进出站（业余时间）的时间。 在那段时间里，只要你不玩手机，一心想着向前，看清前方的路，选择最适合自己的路线，而不是跟着人群往前走，随波逐流，你基本就已经超过绝大多数的人了。 4. 兴趣爱好≠工作 一些初涉职场的人，经常会抱有这种想法，希望找到一份自己既感兴趣，又很擅长的工作，最好还能高薪。 我个人一开始也是这种想法，不过后来就慢慢开悟了。对于绝大多数普通人来说，把个人兴趣和工作绑定在一起，简直就是天方夜谭。 一方面，你真的明白自己的兴趣爱好是什么吗。另一方面，工作是对人类有强烈的内耗和异化作用的，把兴趣爱好当做工作，有可能会毁了你的兴趣爱好。 那既然工作不跟兴趣爱好挂钩，我们该如何做好一份工作呢？我觉得不是兴趣爱好，而是职业精神，详见第5点。 5. 「做事」往往比「天赋」更重要 一些计算机毕业的学生，往往在程序员的职场初期有着天然优势，就是比非科班的要高贵很多。 但是天赋真的是做好一项工作的关键吗？ 第一点我就说了，其实绝大多数初级岗位工作，对于能力的要求是很低的。能胜任岗位的人很多，但真正能把事情做好做成做完美的人，很少。 举例来说，实现一个简单的开发需求，相信很多应届生刚毕业就能做了。但是，他能不能做到准时交付不延期，能不能很好的和团队进行协作，能不能在代码上精益求精，能不能考虑到产品迭代的可维护性，能不能对代码进行详尽的测试，能不能从开发中意识到自己的短板再去弥补，能不能在产品交付后去思考我该怎样去才能做的更好……这些往往和程序员天赋没有关系。 我自己总结了能「做事」的人的三个特点：靠谱、热情、责任心。我觉得只要有这三样，除非是面对那种特别高精尖的工作，单单是对普通的工作而言，哪怕你做不到满分，你也能保底做到80分。 编程金线刚才对一份工作的基本常识就谈了很久，接下来终于要深入程序员的角色了。 「编程金线」是我从冯唐老师那里得到的启发。我觉得在编程领域也有一条金线，程序员达到了就是达到了，没达到就是没达到，对于门外人，若隐若现，对于明眼人，一清二楚，洞若观火。 但是相比虚无缥缈的文字金线，我这里还有两个好消息。 第一，编程金线是可以量化的。 至于什么是好的代码，简单来讲，设计精妙，逻辑严谨。 每种语言都有各自的特点，比如著名的python之禅： 1234567Beautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.…… 在我的职业生涯中，我也经历了从写的代码风格凌乱到逐渐优雅的过程，期间离不开对优秀代码的钻研和我不断地踩坑。有时候，看到一段好的代码，是真的令人赏心悦目啊，而阅读差的代码，简直会让你怀疑人生。 当然，除了语言本身，你还应该关注整个系统的稳定性、可靠性、可扩展性等等。一段好的程序就是一件艺术品，它的上升空间是无穷无尽的，这也使得程序员这份职业有了匠人的特征。 第二，编程金线是可以通过10000小时的刻意练习去够到的。 这一点也不多说了，都是非常常见的理论，要注意10000小时和刻意练习缺一不可。 如果缺少了刻意练习，你只是一直在重复性的工作。 如果缺少了10000小时，你还没真正体会到程序员的职人匠心。 手上有血「手上有血」出自和菜头的一篇文章，我对里面的一段文字印象很深。 和菜头说，他在看履历表的时候，他不会看那些高高挂着的形容词，而是更看重这个人有没有在业余时间里做自己的专业。凡是会这么做的人，是真的喜欢这件事情，哪怕之前做的活儿很一般，未来却不可限量，因为他不怕把手弄脏。 「只要手上有血，意味着一个人之前已经背负过希望和失望，知道成败之间需要的究竟是什么。在他那里，就不会有太多不切实际的幻想，更不会用言辞把这些想法包装起来以获取他人的信任。」 如果说第一部分「基本常识」谈了我对一份工作的初级认识，「编程金线」讲了如何从新手变成高手，那么这里我就要讲如何从高手变成大师了。 但可惜的是，这块内容我没啥发言权，自己连高手都算不上，勉强算一个熟手吧，离大师的路还十万八千里。我想要表达的是，想要成为大师级别的程序员，一定要有「手上有血」的精神，这时候，程序员对它来说不是一份简单的工作，更像是一份人生使命。 我们知道，程序员下限很一般，但是它的上限是真的非常高。从这一点上说，如果你真的愿意在编程之路上上下求索，似乎「35岁辞退危机」也迎刃而解了。 洋洋洒洒写了这么多，其实还是写了不少空话的，毕竟自己不是特别硬核的程序员，也不敢大放厥词，所以不知道写的文字对大家有没有帮助。工作三年，我最近也感到了很多危机感，长江后浪推前浪，一定要再加把劲💪。 最后，有不同意见或想法，欢迎讨论~]]></content>
      <categories>
        <category>比特胶囊</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>编程</tag>
        <tag>职场</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[致高考学子们]]></title>
    <url>%2F2019%2F06%2F09%2F%E8%87%B4%E9%AB%98%E8%80%83%E5%AD%A6%E5%AD%90%E4%BB%AC%2F</url>
    <content type="text"><![CDATA[7年前的此刻，我正在江苏的某教室里做语文试题，开启了整个高考生涯的最后一场战役。 对于早已经通过自主招生被理想的大学提前录取的我，面对高考，自然没什么压力。 我算是没有真正经历过高考地狱的人吧。我觉得自己是幸运的，因为高考实在是太残酷了。但同时我觉得自己也是不幸的，因为没有经历过这名为“高考”的成长洗礼。 我真心觉得，此刻在考场里为了改变命运在奋笔疾书的你们，都是勇士。 虽然我的高考已经过去7年，但是似乎教育制度没有发生太大变化，象牙塔依然是象牙塔，只是外面的世界一直在风云变幻。所以我想，我下面的一些话还是能够给到你们一些启发的，以一个大学四年，工作三年的过来人的视角。 关于考试寒窗苦读12年，最后的命运却由一场考试决定。 这就是高考残酷的地方，不论你此前多么努力优秀，不到最后一刻，依然不能掉以轻心。 我一直很反感应试教育，我觉得这是对人性的剥夺。 但很多时候，我们却不得不这么做，家长很无奈，老师很无奈，为了顺应制度，我们只能服从。 我在高中时代座右铭是，“一分耕耘，一分收获”，我知道每一分的来之不易，希望自己戒骄戒躁，不靠运气，用实力来挣得每一分。 也希望你们都能在考场上发挥出最佳水平，无愧于自己十二年来的努力。 说到底，高考只是一场考试，是人生中的一个小坎。未来，你面临的挑战比高考大的多。 高考考的好，顶多是上了一个好大学，但人生是场马拉松，后面的路还很长。 人生是由无数的选择和机遇构成，没有一马平川的人生，有风有浪有故事，人生才精彩。 如果你没有发挥好，不用太在意，未来依然有机会实现弯道超车。 如果你发挥的很出色，那恭喜你，你为自己增加了人生筹码，你拥有了更多的人生选择权。 关于大学不知道你们是不是和我一样，也相信高中班主任的话：高中好好努力，到了大学就轻松了。 我当时就天真的信了这句话，结果大学过得很惨。 玩了四年，一无所获，被同辈的小伙伴们甩下了很远，毕业后才醒悟却为时已晚，错过了最宝贵的学习时光，还没做好准备，就要面对未来接踵而至的无尽挑战。 所以，不要听信那个谎言，还是那句话，高考只是人生中的一个小坎，他是一个成长的洗礼，你从此打开了一个花花世界，离开了应试教育模式，开始在无限人生可能性中进行探索。 大学给我的回忆是美好的，毕业三年，我依然怀念129的歌声飞扬、北区的食堂、3108的讲堂，和光华楼门前的大黄。好想重回校园，可惜人生无法逆流。 如果让我用一个词来概括大学的意义，我觉得那必须是“求索”。进入了大学，就好像进入了一片灿烂的星空，无数的大师如星辰般指引着我们前进，同学们如星辰般交相辉映。无论是社会实践，还是学术探究，还是学术活动，不同于高考前单一的考试标准，我们可以尽情的去探索世界，以及探索自己。 大学对我来说，最大的帮助是让我看到了无限的可能性。虽然自己一事无成，但是我看到了人生的不同活法，当时同行的小伙伴，有的醉心学术，即将赴剑桥读博士，有的毕业进入了大公司，成为了中流砥柱，还有的，半路转行，找到了自己的满意的方向。当然，更多的还是像我一样的普通人，在平凡的岗位上努力做着不平凡的事情。 我们各自演绎着属于我们自己的人生。 人生道路，没有对与错之分，只有适不适合自己。 关于爱情关于这一点我是比较汗颜的，活了25年，我还没有谈过恋爱。 一方面我享受着单身日子，觉得自己还是一个孩子，关于自我的探索，还有很多事情没有做完，不想因为恋爱而分身乏术。 另一方面，在如今这个时代，找到灵魂伴侣也越来越难了，每个人都是一个独立的个体，能够充分利用互联网做到自我完备，恋爱从过去的必需品也慢慢过渡到了可选品。 这里说一些老生常谈的观点吧。 要区别爱情和婚姻。爱情是理想主义的，婚姻是现实主义的，年轻的时候，尤其在大学，没有太多的拘束，不需要考虑那么多现实因素，大可以谈一场刻苦铭心的恋爱。等到工作后，现实的考量会越来越多，谈恋爱找对象，更多的该以婚姻为目的。 在爱情里，不要试图去寻找一个完美的人，因为在完美的人身边，你是多余的，完美的人不需要别人。所以，爱情不是你和一个完美的人相爱了，而是Ta爱了你之后，他才更趋完美了。爱情就是两个不完美的人，共同创造一个完美的关系。而保持爱情长久的一个办法，就是要尽可能保持你们在精神上同步而行。 关于工作关于工作，我非常提倡胡适老师在一篇文章里讲的三个点。 第一是要时时寻找一两个值得研究的问题。所谓“为知识而求知识”，时刻保持好奇心和求学的热心。 二是多发展一些非职业的兴趣，毕业后的第一份工作往往不是你真心喜欢的，或者是和你性情不相近的。这种情况下，为糊口而做那种非“性之所近而力之所能勉”的工作，就很难保持求知的兴趣的生活的理想主义，最好的救济方法只有多多发展职业以外的正当兴趣与活动。想要生活不苦痛不堕落，就要多方面发展业余的兴趣，使精神有所寄托。 第三个方法是，你得有一点信心。胡适所在的时代是不幸的，然而当今的互联网时代充满着无数的机遇和可能性，更应该对未来充满信心。 有个词叫“功不唐捐”，意思是没有一点努力会白白丢掉。人生每一步都会算数，希望我们都能珍惜好青春日子，努力奋斗，谁也不希望在回忆往事的时候空留遗憾。 关于人生我觉得关于上文提到的“高中好好学习，大学后就可以玩了”这样的言论简直是误人子弟。 如果把它改一下，我想改成： 人生是困难重重的，没有哪一段人生是可以轻轻松松度过的。对高中生们来说，我们努力学习，不单单是为了在高考时取得好成绩，而是锻炼我们战胜困难的能力。毕竟年轻时候，失败成本还比较低，高考时你们最大的敌人，而一旦进入社会，你会更加谨慎，再也不能随便失败了。 所以趁着年轻，勇敢的试错，不惧风险，这是你最大的资本。 无论是高考，大学，还是工作，我们所有的努力，都是在增加自己的人生筹码，让自己未来的路走的更加顺利，选择权更多。 祝考场上的你，能交出满意的答卷。 祝人生道路上的你，永远保持少年模样，不忘初心，砥砺前行。]]></content>
      <categories>
        <category>光阴的故事</category>
      </categories>
      <tags>
        <tag>人生</tag>
        <tag>总结</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[裸辞是一种怎样的体验]]></title>
    <url>%2F2019%2F06%2F09%2F%E8%A3%B8%E8%BE%9E%E6%98%AF%E4%B8%80%E7%A7%8D%E6%80%8E%E6%A0%B7%E7%9A%84%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[2019年5月14日，我正式入职心仪的新公司，也意味着我从2018年11月23日以来，长达172天的，接近半年的，裸辞后的空窗期，正式宣告结束了。 谈到这段裸辞经历，我觉得这不仅仅是一段简简单单的破除职业迷茫的故事，更是一份时光赐予我的礼物，它让我找到了自我，让我不再迷茫，让我更有力量去搏击人生。 我的将分四个阶段去讲述我的裸辞生涯裸辞：裸辞前，裸辞后，结束裸辞前，结束裸辞后。 裸辞前我是一名程序员。 16年7月，本科毕业后来深圳工作，满怀壮志，梦想着创造出一片天地。 没想到在的一年之后，激情便开始消退，每天开始重复工作，人也变得麻木，浑浑噩噩，没有目标。 我开始审问自己：我真的适合做程序员吗，这样下去我该怎么办。 因为公司的环境相对宽松，日子过得像温水煮青蛙，虽然在17年就有了辞职的念头，但迟迟没有行动。 记得电影《无问西东》里有这么一个故事： 民国时期的吴岭澜文科成绩第一，物理成绩确榜上无名，老师劝其转文科，他迷茫不决：“因为最好的学生都念实科”。 时任清华校长的梅贻琦对他说：“人把自己置身于忙碌中，有一种麻木的踏实，但丧失了真实。” 吴岭澜问：“什么是真实？” 梅校长答：“你看到什么，听到什么，做什么，和谁在一起，有一种从心灵深处满溢出来的不懊悔也不羞耻的平和与喜悦。” 梅校长的话对我来说有如当头棒喝，我此刻的工作状态，不就是一种“麻木的踏实”吗，我渴望真实，渴望那种“从心灵深处满溢出来的不懊悔也不羞耻的平和与喜悦”，这种感觉，我已经太久太久没有体会到了。 再后来，我又看了电影《搏击俱乐部》，里面的“self-destruction”疗法给了我很多勇气：It’s only after we’ve lost everything that we’re free to do anything. 一年后，2018年行将就木，我觉得不得不做出决定了，辞职已经是板上钉钉的事，不破不立。 我选择了裸辞，因为我知道现在的状态很差，即使入职下一家公司，也不可能保证工作的激情。 我想暂时忘记工作，希望在一段安静的时光里好好思考未来的路。 我还年轻，年轻就意味着可能性，我不想早早地把这份可能性给扼杀，而陷入买车买房升职加薪等世俗逻辑。 我觉得每个年轻人都不应该被世俗绑架，都要努力去走出属于自己的道路。 我想是在自己身上做了一场实验，看下当远离工作的我是否能创造出奇迹。 我储备了三个月的薪水，这些钱大概能让我在深圳无压力生活半年。 2018年10月24日，程序员日，在这个有着特殊意义的一天，我向领导提出了辞职。 裸辞后一个月的交接期，我奋战到了最后一刻，坚持在站好最后一班岗，跟公司和平分手。 2018年11月23日，我回收了工牌，最后一次迈出了公司的大门。 “仰天大笑出门去，我辈岂是蓬蒿人。” 此时我的步伐无比轻盈，我知道我终于冲破了桎梏，开始迈向新的人生。 辞职后，我并没有停下脚步。我知道裸辞代价很高，这段自由时光来之不易。 我必须要好裸辞后的空窗期，去完成以下事情的探索：我是谁，我想成为谁，我该怎么做。 职业生涯理论说，好的职位是兴趣、能力和社会需求的结合点。 如今事后总结来看，我的空窗期大体就是按照这三个关键词执行的。 裸辞后的故事可分为三个阶段。 第一阶段，自由探索时期（12月——1月） 这段时间，我想暂时忘掉工作，忘掉程序。 我想动用身边一切所能找到的资源，去探索，去尝试，去拓展疆界，去发现本心。 于是，在18年的最后一个月，我发疯似地去体验不一样的生活。 深圳的大小展览，交流活动，课程讲座，只要是对我有帮助的，都一场不落地去参加；我开始学摄影，学画画，逛书店，尝试之前没有做过的事；我找到许久未见的朋友，与他们畅聊人生，去解锁别人的人生密码…… 特别要说一下深圳的诚品生活，它真的帮助了我很多。 12月份开业后，我就成了那里的常客。诚品生活会举办很多大师讲座和文创讲座，我从那里汲取了很多力量。 比如，梁文道老师在主题为“何遣有涯之生”的讲座说，他感受到了社会上越来越迷茫的虚无感，他主张年轻人在工作之外，找到能够发挥自己潜力的事情，从而对抗这份虚无。 再比如，诚品生活的各类文创讲座，让我看到了在AI肆虐的今天，关于人性、情感、温度、创造以及爱的价值。 余不一一。 总之，在经历了一系列个人探索之后，如果不考虑所有的现实因素选一份dream job，我想成为一名设计师。 第二阶段，能力培养时期（1月——3月） 在第一阶段确立好目标之后，我开始朝这个去努力。 我选择了设计师领域里我最熟悉的UI设计作为岗位切入，开始调动身边的一切资源去了解这个行业，去学习相关技能。 那段时间呆的最多的地方就是宝安图书馆了，很喜欢那里的自修室，有种梦回大学的感觉。 其实不光是图书馆，城市为我们提供了诸多便利，只是我们在工作的时候，没有好好去享用他们罢了。 临近三月，我开始嗅到了春招的气息，要开始投简历了。 可是我发现，其实UI设计的初级市场已经饱和了，我丝毫没有竞争力，我也不可能利用短短两个月就成为一名设计师。 另外我的资金告急，我必须选择一条更切合实际的路。 于是就来到了第三阶段。 第三阶段，社会接轨时期（3月——5月） 事实上，兴趣和工作是可以分开的，如果把兴趣当做工作，往往会毁了你的兴趣。 设计为我打开了新的世界，我把它作为自己的爱好，用来填充工作之外的虚无感。 在选择工作方面，我还是要现实一点。我梳理了目前手上的筹码，希望结合自己的爱好和优势来选择未来的工作。 于是，我选择了前端。你可以粗浅的认为，这份工作是程序员+设计师，一个维系了上下游的岗位。 当我找到了这个答案，我的世界仿佛明亮了起来。 这是一个真正的兴趣+能力+社会需求的结合点。 3月份起，我就开始了漫长的前端学习之旅，并且结合招聘网站上的岗位介绍，对知识盲点查漏补缺。 3月末，我觉得是时候投递出第一份简历了。 结束裸辞前在寻找到自我，培养好能力后，我整个人已经焕然一新，浑身充满了力量，走路带风，目光如炬。 我将开启我的求职之旅，记得上一次海投简历还是三年前校招的时候。 不过，我还是低估了社招的难度，我的求职过程异常艰难。 从人的角度说，深圳的前端工程师的初级市场已经饱和了，而我作为一个从后端转前端的程序员，缺乏实战项目也成了我的个人劣势。 从企业的角度说，社招主要是缺人招人，很少有公司愿意招一个小白进去培养的，而且今年恰好碰上了互联网寒冬，放出来的岗位甚少。 此外，面试是一个很累的过程，尤其是对于裸辞的同学来说，他们已经与社会脱离太久了，频繁的面试失利或许会打击自信心，面临崩溃。 不过还好，我的努力稳住了这一切。 短短一个半月，我几乎跑遍了深圳所有的写字楼。 面了20多家公司，拿了5份offer。 这段时间里，我学会了如何高度自律，如何高效学习，如何反馈总结，如何正确沟通，如何保持心态……总之，裸辞期间的求职经历，把我训练成了一个怪物。 已经五月份了，金三银四招聘季已过，再往后也很难有更多好的机会了。 我知道我的裸辞生涯就要结束了，该做决定了。 结束裸辞后2019年5月14日，我正式入职了心仪的岗位，成为了一名前端工程师。 我属于闪电入职，从一面二面到签offer进入公司只花了三天。 我想这也是裸辞的好处，不必要去理会那些繁琐的离职手续和漫长的交接期。 认识了新的同事，参与了新的项目，一切都是那么新奇。 我很喜欢目前的工作，很庆幸自己，没有在面试最累的时候选择将就，而是坚持面试，等到了这家公司的出现。 也许你会说，我绕了一圈怎么还是一名程序员，裸辞的意义到底是什么呢？ 我在裸辞之前，也早已料到，也许未来我还是一名程序员。但我相信，在经历了那么多后，此时我的心境一定和过去的我不一样了，有些事情是只有你真正尝试后才能感受到的，即便会因此撞了南墙。 如今，我更加认同了自己的程序员身份，并且在工作之外拥有了去抵抗人生虚无感的能力。 我因为迷茫而选择了裸辞，未来，我也许会再次陷入迷茫。但我想，此时的我，已然拥有了战胜迷茫的力量。 另外，裸辞期间，我对自己的认知，我的能力积累，我的做事方法，我的坚持与韧性，这些都成了我不可多得的财富。 我觉得我未来不会再裸辞了，毕竟这是一件代价很高的行为，一次已经够你折腾了。 而且，裸辞只是解决问题的最极端的手段，事实上还有很多手段可以帮你破除迷茫，只是当时的我太过麻木，只得出此下策。 当然，我知道，裸辞只是人生成长中的一个小插曲，未来所面临的挑战，远比裸辞要大很多。 最后， 祝福所有人在职业道路上都能事事顺心。 祝愿所有人都能被世界温柔以待！]]></content>
      <categories>
        <category>人在江湖</category>
      </categories>
      <tags>
        <tag>职场</tag>
        <tag>梦想</tag>
        <tag>裸辞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[你好，这里是我的个人站点——“知鱼之乐” 我热爱写作，我将在这里分享我的成长感悟、技术总结、书评影评 希望我的文字能够对你有所启发或帮助 欢迎加微信交流：wx-sunxiaoyu]]></content>
  </entry>
</search>
