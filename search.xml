<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[聊一聊程序员职业(2021版)]]></title>
    <url>%2F2021%2F06%2F08%2F%E8%81%8A%E4%B8%80%E8%81%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E8%81%8C%E4%B8%9A(2021%E7%89%88)%2F</url>
    <content type="text"><![CDATA[在《聊一聊程序职业(2019版)》里，我粗略介绍了一下我对程序员职业的认知。有经历过两年的沉淀，再加上市场环境的变化，我现在对这个行业的认知更加丰富而深刻了，分享下我的见解。 迷茫的开始对于刚毕业工作1-3年的程序员，由于经验不丰富，干什么都觉得特别新鲜，很有干劲，这段时间也能得到快速的成长。可是3年之后，他就会发现，似乎公司里做的东西都得心应手了，每天更多的是在重复劳动，进入了舒适区。再加上精力上也比不上公司的新人了，年纪大了也要面临35岁危机，于是他便开始陷入迷茫。 其实这是正常现象，如果你没有很长远的目标，或者习惯随波逐流，很容易不知所措。 职业生涯早期，我们有明确的目标，工作内容主要是完成手上的任务，工作模式比较单一，等到工作资历渐长，无论是我们自己，还是这个行业，都不会允许我们裹足不前，这就需要我们开始觉醒。 叔本华说，人生就是一团欲望，欲望不能满足便痛苦，满足了便无聊，人生就在痛苦和无聊之间摇摆。 所以人生其实是螺旋式上升的，我们能感受到自己的迷茫是好事，至少此时你已经发现了问题。这时候就要采用积极的行动去解决问题。毕竟程序员的本质就是去解决问题。 内卷与焦虑谈完了个人，接下来我们来看看外面的世界。今年关于“内卷”的讨论特别火，由于僧多粥少，程序员行业的竞争也变成存量竞争，大家的竞争愈发激烈，行业门槛也越来越高。 当行业红利消散，便到了理性思考的时候，无论是行业还是个人，都应该去多考虑一些更长远的事情。 社交网络在大肆渲染着焦虑，我们太容易被程序员高薪表象所吸引，进大厂拿高薪似乎也成了每个程序员的唯一归宿，大家为了这个目标开始了疯狂的行动，每个人活得很累也成了必然结果，这个社会也越来越卷。 这个时代，焦虑已无法避免，作为程序员，是时候该要思考如何破局了。 破局之道身处内卷的浪潮之中，我在最近一两年也在不断思考，如何成为一个更加厉害的程序员，提高自己的竞争力，让自身更有价值。我从个人经历角度，总结了以下五点，欢迎讨论交流： 1. 打好基础我不是科班出身的程序员，在职业道路上踩了很多坑，走了很多弯路，这些都是我血泪的教训。曾经的我只是满足于完成工作任务，但是现在的我明白了越高级的程序员，绝不只是完成任务那么简单，更需要很广博的知识和很深厚的功底，方能支撑去做好系统架构。 而对计算机基础知识的掌握深厚程度，很大程度上决定了一个程序员所能到达的上限。这些内容，即使是科班出身的同学，毕业几年后也会忘，更何况是非科班出身的同学呢，他们更没有理由去浪费时间，需要花别人好几倍的功夫去补足它们。 这些基础知识包括数据结构和算法、操作系统、计算机网络、编译原理、计算机体系结构等等。每一门完全掌握都要花很多功夫，需要投入大量精力。程序员是个需要终身学习的职业，必须学会享受其中。 2. 构建体系程序员所掌握的知识远不止前面提到的计算机基础，是一个浩瀚的海洋。包括Java/go/python，设计模式，并发编程，开发框架，数据库、缓存、消息队列，分布式微服务，服务治理，限流熔断降级…… 面对浩如烟海的知识，要达到高效学习，最重要的是要构建自己的知识体系。 学习上也有飞轮效应，指为了使静止的飞轮转动起来，一开始你必须使很大的力气，一圈一圈反复地推，每转一圈都很费力，但是每一圈的努力都不会白费，飞轮会转动得越来越快。 最开始构建好知识体系是难的，等到大厦的结构建成，心中有了整体的认知，后面学到的知识都是在上面添砖加瓦，反而会变得简单。 等到知识掌握到一定程度，就会发现，其实编程里面很多知识都是相通的，构建知识体系帮我们形成了结构化思考的能力，工作越来越游刃有余。 另外再说一点，很多程序员工作几年后会发现，公司里做的东西非常普通，根本不涉及我前面提到的那么多的技术。确实，这也是行业通病，面试造火箭，工作拧螺丝。但我想，每个人都是在为自己的简历打工，即便工作之中用不到这些技术，自己也要主动去学，并且主动思考能否运用到业务中。这也是高级程序员和普通程序员不同的地方。 3. 知行合一前面两点一直在讲学知识，但是学而不思则罔，真正让我们学会知识的，是要亲自去实践，去用知识。 所谓“听过很多道理，但过不好这一生”，听到的别人的经验永远不是自己的，只有通过实践总结才能真正成为自己的。 这需要我们平时在学习的过程中，不能浅尝辄止，多去思考知识的实际使用场景，并去加以应用，哪怕工作中用不上，自己也可以写一些demo，做一些开源项目等等，把自己的想法付诸实践。 此外，以教为学也是一个很好的检验自己是否掌握知识的方式，可以多尝试总结和输出，这同时也是构建知识体系的好的方式。 最后，也可以寻找一些学习社群或者技术组织，跟更多的程序员相互切磋，共同成长，避免一个人学着学着迷失了方向。 4. 志存高远我知道除了极少数的对编程抱有极大热情的程序员之外，绝大部分程序员只是希望凭着提升自己的技术进大厂，去更好的平台那更高的薪酬，学习编程更多是成了他们升职加薪的工具。 我当然不否认他们的做法，但是我也发现很多人其实对编程并不那么感兴趣，但又有进大厂的梦想，于是每天学得苦不堪言，但是靠着自身的坚持一路走到现在。 在这里我想说，只靠坚持一定走不长远，我们或许可以赋予编程更崇高的意义去引领我们行动，而不是简单的为了求职面试。比如，学习编程是为了让我们成为更好的自己，让我们去养成科学的学习方法，以及不断给自己磨炼去培养各方面的能力，让我们认识到世界的疆界和自我的局限，甚至让我们看到突破自己极限所带来的的巨大能量。 既然入了这一行，不管热爱与否，通过不断学习，让自己保持着竞争力，让自己的能力匹配上自己的资历也是匠人精神的体现。 左耳朵耗子叔曾说一句话：要应付并通过面试并不难，但是，千万不要应付你的人生，你学技术不是用来面试的，它至少来说是你谋生的技能，要尊重自己的谋生技能，说不定，哪天你还要用这些技能造福社会、改变世界的。 5. 但问好事最后，但问好事，莫问前程。 我能感受到这个时代的内卷和焦虑永远不可抑制，只会逐渐加深。现在“躺平”的呼声也很高，越来越多的人意识到工作生活平衡的重要性，抵制无节制的内卷。 对于我自己，坦然接受那些不能改变的，勇敢去做那些我能改变的，并学习去分清两者的区别。 人生没有白走的路，每一步都算数。心中有目标，行动有规划，日拱一卒，功不唐捐。 特别喜欢《传习录》里的一段话： 立志用功，如种树然。方其根芽，犹未有干；及其有干，尚未有枝；枝而后叶，叶而后花实。初种根时，只管栽培灌溉，勿作枝想，勿作叶想，勿作花想，勿作实想。悬想何益？但不忘栽培之功，怕没有枝叶花实？ 最后，祝福大家的职业之路都能一帆风顺！]]></content>
      <categories>
        <category>比特胶囊</category>
      </categories>
      <tags>
        <tag>职场</tag>
        <tag>编程</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法面试指北]]></title>
    <url>%2F2021%2F04%2F22%2F%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8C%97%2F</url>
    <content type="text"><![CDATA[算法面试一直是程序员大厂面试中的必备环节，本人自从系统性的学习了数据结构与算法之后，对这一块内容已经积攒了大量的实践经验，同时也参加了不少面试，对如何准备算法面试也有了自己的理解。接下来，我将从学习思路、学习工具、训练方法、模拟实战这四个角度，去分享我的经验。 思路篇——博观而约取，厚积而薄发时间复杂度，空间复杂度时间复杂度是衡量算法执行效率的重要指标，空间复杂度是衡量算法消耗空间的重要指标。 根据算法种类的不同，时间复杂度可以达到常数级，线性级，指数级不等，能否使用最高效的算法，或者说最优的时间复杂度完成编程开发，是衡量软件工程师素质的重要指标。 数据结构程序=数据结构+算法。作为软件工程师，需要对常见的数据结构了如指掌，它们包括： 一维数据结构： 基础：数组 array (string), 链表 linked list 高级：栈 stack，队列 queue, 双端队列 deque, 集合 set, 映射 map,二维数据结构： 基础：树 tree, 图 graph 高级：二叉搜索树 binary search tree (red-black tree, AVL), 堆 heap, 并查集 disjoint set, 字典树 Trie 算法思想除了各种数据结构，软件工程师还需要掌握各种常用的算法思想，它们包括： 递归 Recursion (Divide &amp; Conquer, Backtrace) 搜索 Search: 深度优先搜索 Depth first search, 广度优先搜索 Breadth first search 动态规划 Dynamic Programming 二分查找 Binary Search 贪心 Greedy 数学 Math , 几何 Geometry 以上基本列举了算法面试的常考知识点，算法初学者可以先针对每个知识点具体学习，基础很重要，这些是灵活掌握算法的基础。 工具篇——工欲善其事，必先利其器知识vs技能前面一篇主要列举了算法面试中的常考点，但是只局限于知识的层面。想要真正把知识转化成技能，就需要不断的练习。至于如何高效练习，我推荐leetcode网站，http://leetcode-cn.com/ leetcode该网站有大量的算法题，可以在线提交代码检查运行情况，还能参考各路大牛的题解。 通常来讲，在网站上做完300+道题目，就可以基本达到面试大厂的水准。 接下来，我将介绍如何利用该网站进行高效的刷题。 训练篇——积土而为山，积水而为海刻意练习刻意练习就是有针对性的反复训练，算法也一样。 leetcode网站提供了各种类型算法的标签分类，可以选择自己薄弱的地方针对性的练习。 另外，针对某一道特定的问题，在做完之后，也要学会去看题解，学习各种各样的解法，在这个过程中体会各种算法优劣的比较，并寻求最优的时间复杂度。 寻找反馈对于算法初学者而言，刚接触算法是一个非常难熬的过程，你会感到非常的挫败，容易丧失学习的动力。 这时候，一靠自律，你必须努力使自己有攻克算法的强烈渴望，比如为了跳槽，为了更高的薪水等等。二是靠反馈，你可以加入一些刷题社群，跟小伙伴们一起学习，互相督促。另外leetcode网站上可以显示你的全站排名，以及刷题数目，也能给予你一定的正反馈。 温故知新人的学习会有遗忘曲线，有的题目，即便是你当时看题解后会做了，隔了几天后也许又不会做了。 这很正常，不需要害怕，你要做到的就是过遍数，重新去温习一下这道题。通常来讲，一道算法题，做完五遍以上，才能算真正的掌握。 建立体系学习的宗旨是为了掌握它，如何掌握浩如烟海的知识，就需要构建出属于自己的知识体系。把一个个点给连缀成一条线，清楚地认识到每一个知识点所在的位置，才能在做算法题时做到游刃有余。 实战篇——凡事预则立，不预则废经过了前面几个步骤的练习，你已经掌握了各类数据结构和算法，对常考题的各种解法也了然于心，我想此时你一定对面试跃跃欲试了。 可是，面试时做题目跟平时自己联系题目是有区别的，在面试的场景下，很容易由于压力过大或者不习惯白板做题的方式而发挥失常。对于如何针对面试进行训练，我总结了以下几点： 练习白板编程平时的开发大多是借助IDE（集成开发工具），但是真实的面试中，面试官极有可能就给你一张白纸去写代码。如果是线上面试的话，还可能会借助一些网页工具，实时的共享代码，例如https://codeshare.io/ 所以，在平时训练算法题的过程中，要注重自己白板编程能力的培养，这对编程能力，以及代码风格的要求很高，需要多加练习。 自己想测试用例在平时的练习里，你可以通过在leetcode上提交代码，很快地知道哪个用例没有通过，而在真实的面试中，面试官很少会给你提供测试用例，需要你自己去考虑各种边界情况。 所以，平时在leetcode上练习时不要急于提交代码，在心里先把各种异常场景想清楚，比如输入值校验，边界情况，大数据量带来的时间复杂度等等，这个过程也是在训练自己的思考能力。 模拟面试你可以找你的朋友或同事帮助你进行一下模拟面试，在面试之前先给自己找到面试的感觉。 另外，leetcode提供的模拟面试的功能也很有用，我就特别喜欢用它来模拟真实面试场景，限时去完成题目。 总结学习算法的过程比较枯燥，但它作为程序员的一项内功，是非常值得重视的。 篇幅限制，本文只是简单的概括了我在学习算法过程中的一些经验，很多地方没有展开，等到后面有空，再针对具体的案例进行升华。 如今，程序员行业的竞争已经越来越激烈，算法能力也越来越重要。如果你打算在行业内长期发展，这一块永远是不可或缺的技能，越早掌握，越是快人一步。]]></content>
      <categories>
        <category>比特胶囊</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统设计面试指北]]></title>
    <url>%2F2021%2F04%2F15%2F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8C%97%2F</url>
    <content type="text"><![CDATA[系统设计的问题是在国内外大厂面试的常考题，这类问题开放性比较强，没有标准答案，比如设计微博，设计微信，或者是设计某个特定功能，如限制用户的访问频率。 面试官的问题可能很大，但是让你设计的东西未必会很多，设计的难度也未必会很大，极有可能从易到难引导你先设计一些简单的结构。所以掌握这类问题的面试技巧很重要。 如何应对这类问题，我在一个教程上学习到了4S法，总结如下： 4S分析法中的4S是指Scenario（场景），Service（服务），Storage（存储），Scale（扩展）。 第一步：Scenario 场景在这一步，你需要询问面试官：需要设计哪些功能（也可以自己想），需要承受多大的访问量。 就以设计微博为例，可以把微博的功能一一列出来，但显然无法在短短的一小时的面试里完成所有的功能设计，所以要筛选出核心的功能，比如发微博和浏览微博。 另外，需要考虑系统所承受的QPS（每秒查询次数）大概是多少，需要考虑并发用户，读写频率并掌握相关的计算方法，对一些经验性的数值要记得。 比如一台web服务器的承受量约为1k的QPS，一台关系型数据库的承受量约为1k的QPS，一台非关系型数据库的承受量是10k的QPS。 第二步：Service 服务所谓服务可以理解为逻辑处理的整合，将同一类问题的逻辑处理处理的整合，对于同一类的问题的逻辑处理可以归并到一个服务。这一步实际上就是将整个系统细分为若干个小的服务。 比如以设计微博为例，我们可以拆分成用户服务，微博服务，关注关系服务，媒体资源服务等等。 第三步：Storage 存储这一步是4S分析法中最重要的一部分，需要根据每个服务的数据特性选择合适的存储结构，然后细化数据表结构。 系统设计中可以选择的存储结构一般有三大类：数据库系统，文件系统，缓存系统。其中数据库又分为关系型数据库（例如MySQL）和非关系型数据库（NoSQL）。 以设计微博为例，根据前面拆分的服务的特点，用户服务适合用MySQL存储，而微博信息适合用文档型数据库MongoDB存储，多媒体资源可以借助文件系统，如AWS S3，对于热点数据，还可以用Redis做缓存。 另外，我们要向面试官展示数据存储和读取过程。就以微博的feed流为例，如何拿到新鲜事列表，可以采取pull和push两种方式，pull的方式实时的去获取关注人的微博，并做多路归并，push的方式会为每个用户维护自己的新鲜事的记录。 我们要在方案的取舍中体现出自己的专业性，以及tradeoff的能力。 第四步：Scale 扩展经过前面3个步骤的分析，我们已经得到了一个解决方案，但这个方案还有很多的缺陷，所以需要4S分析法最后一步，扩展。 这一步分为两个部分，一个是优化，包括解决涉及缺陷，更多功能设计以及一些特殊情况如何处理。另一个是维护，包括系统的鲁棒性和扩展性，比如有一台服务器挂了怎么办，比如鹿晗公布恋情导致流量激增怎么办。 总结最后总结一下系统设计面试过程中的注意点： Ask before design. 先跟面试官明确需求再动手设计，不要一上来就冲着一个巨牛的方案去设计。 No more no less. 不要总想着去设计最牛的系统，而是设计够用的系统。 Work solution first. 先设计一个基本能工作的MVP产品，再逐步优化。 Analysis is import than soluton. 系统设计没有标准答案，记住答案是没用的。通过分析过程展示你的知识储备，并权衡各种设计方式的利弊。]]></content>
      <categories>
        <category>比特胶囊</category>
      </categories>
      <tags>
        <tag>系统设计</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计原则与生活]]></title>
    <url>%2F2020%2F09%2F29%2F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E7%94%9F%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[在面向对象程序设计领域，有5条非常重要的设计原则，它们的首字母拼起来，正好是S.O.L.I.D这个单词，因此也称SOLID原则。SOLID原则能够指导程序员有效避免代码中的坏味道，从而开发出易于维护和可扩展的软件。 然而SOLID原则比较难以理解，包括我自己也常常会记不全，我特别希望能把技术去应用到生活里，通过与生活的结合，去从新的维度思考技术发展的本质。因此我尝试把设计原则结合生活实际，把它们重新阐述一遍。 S——单一职责原则，Single-responsiblity principle从代码角度来讲，一个类只能承担一个职责。通俗点儿说就是一个类只能承担一件事，并且只能有一个潜在的原因去更改这个类，否则就违反了单一职责原则。 例如，筷子是用来吃饭的，勺子是用来喝汤的，刀叉是用来吃西餐的，从来没有一样厨具可以把所有的功能兼容包并，即便有那样的厨具存在，对于使用成本来说也太大了。 无论是在编程，还是在其他领域，都主张一件事物只做一件事情，只有把职责划分的足够细，功能才会明晰。 从工作角度来说，因为分工产生了协作，因协作而提升了效率，每个人都要明确自己的职责，以防在协作的过程中含糊不清，增加讨论交流的成本。 也许你会说，手机既可以拍照，也可以打电话，也可以玩各种app，它能做很多件事情，是否违反了单一职责原则？其实不然，手机是一个上层的系统，而构成手机的无数个组件都是按照单一职责来划分的。单一职责看的是局部，而不是整体。 O ——开闭原则， Open-closed principle软件实体应该对扩展开放，对修改关闭。允许扩展行为而无需修改源代码。 说回手机的例子，我们之所以能够在手机上下载各式各样的应用，其实就跟开闭原则有关。手机提供了一个平台，为各类app提供了很多的基础能力，而各个app按照自己的应用场景去定制开发，然后使用者使用安装app的形式，去获得这部分的功能。因此对手机来说，它本身的修改是关闭的，但是对功能的扩展是开放的。 试想，如果手机违反了开闭原则，则每次想要获得新功能，都要首先升级手机自身的程序，安装app就会变得特别繁琐。 再比如，吹风机可以搭配不同风格的出风口，充电器可以搭配不同型号的充电线，这些都是很好的开闭原则的例子。 我觉得开闭原则对我们人生也有很多启示，如果我们自己能够形成一以贯之的人生方法论，不用每次获取新知识时都把自己推翻和重建，是不是在获取新知的过程中效率更高了呢？ L——里氏替换原则，Liskov substitution principle程序中的对象应该可以被其子类实例替换掉，而不会影响程序的正确性。 例如做菜的时候，你可能要放食用油，但是油分为好多种，比如大豆油，橄榄油，花生油，菜籽油等等，这些品种都是食用油的子类，每一种都可以进行替代。 谈到替换两个字，我不禁想到了作为程序员，很容易被更年年轻的程序员替换，如果一个程序员只是满足于当下的工作，完全按照既定的父类的框框去做事情，不注重技术的创新和知识的迭代，那往往就会被更多的新的子类程序员替换掉。 所以代码要遵从里式替换，但是职业发展拒绝被里式替换。 在编程开发中，往往只要代码符合了里式替换原则，也很难不符合开闭原则，对于不符合里式替换原则的场景，又可以借助下面的接口隔离原则来实现。 I ——接口隔离原则，Interface segregation principle使用多个特定细分的接口比单一的总接口要好，不能强迫用户去依赖他们用不到的接口。 举个简单的例子，麻雀，燕子，鸽子，鸵鸟都是鸟，但是鸵鸟不会飞，对于会飞这个属性来说，就不能独属于鸟，而应作为鸟类的一个接口。 接口隔离原则也体现了继承和组合的区别，如果是继承，继承使得父类暴露了过多细节给子类，也使得父类难以改变，而组合则更加灵活，是一种更方便的扩展手段。 扯远一点说，接口隔离原则是承认了世界的复杂性。没有一项事物是我们能够用单一标准所评价的。 D ——依赖倒置原则，Dependency Inversion Principle程序要依赖于抽象接口，而不是具体实现。高层模块不应该依赖于低层模块，二者都应该依赖于抽象抽象不应该依赖具体实现，具体实现应该依赖抽象 简单来讲，实现依赖抽象，存在一个总的原则在指导我们，而具体的实现细节可以自由把控。 比如做一道炒菜，你可能需要买菜、备菜、炒菜、出锅等必要工序，具体去那里买，具体怎么切菜，用什么锅炒菜都可以自由发挥，但是整体的做菜过程是千篇一律的。 再比如，我们每个人从出生，到上学，到工作，到成家立业，也是在一个大的框架体系下进行的，这种框架类似于某种社会共识，而每个人都是这个社会共识的具体实现，如果没有了这个框架，个体自由度过大，则会加剧社会的维护成本。 能否灵活运用依赖倒置原则，也是判断一个程序员是否资深的重要标准。高水平的程序员应该用框架来指导开发，而不是拘泥于细节，编程领域的很多框架，例如spring,tomcat都运用了依赖倒置思想。 以上5点设计原则对于编程设计来说，尤为重要。对于已经有一定经验的程序员，在日常工作开发中，一定要对自己的要求更高一层，而设计原则能够指导代码往增强可测试性和更易于维护的方向转变，是非常不错的优化方向。]]></content>
      <categories>
        <category>比特胶囊</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统设计面试指北]]></title>
    <url>%2F2020%2F05%2F29%2F%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E7%AA%81%E7%A0%B4%E8%81%8C%E4%B8%9A%E7%93%B6%E9%A2%88%2F</url>
    <content type="text"><![CDATA[转眼也毕业四年了，期间跌跌撞撞，但好歹也是一路在向前成长，职业成长算是冲破重重迷障，进入了一个良性循环。最近一直在思考如何突破当前职业困境，实现快速发展，于是总结了一系列的职场思考。本文内容多是针对像我一样，毕业工作3-5年的程序员，希望能对你有帮助。 硬实力作为一个已经工作多年的程序员，是什么让你有别于那些初来乍到的程序员小白，一个很重要的区别，就是你在这个领域已经深耕多年，必须努力去成为某一块领域的专家，即你必须要有足够和你的工作年限相称的硬实力。 所以，我把这个几乎各行各业都适用并且已经老生常谈的真理放在第一点——一万个小时的刻意练习。 proactive英语里有一个词，叫做“proactive”，我觉得它的释义非常好： taking action to make changes yourself rather than reacting to things that happen. 你在程序员的日常工作中，到底是只应付领导安排的工作，一项一项的完成，还是在工作中有自己的思考和总结，主动去做更有价值的工作。 举个最常见的例子，比如说开发的系统出现了一次线上事故，普通的程序修完这个bug就完事了，丝毫没有更深的思考，这也是缺乏责任心的表现。 稍牛逼的程序员，会评估下这次事故的影响面，把事故的影响数据做一个修复，同时做好相关测试，以防止这类bug再次发生。 更牛逼的程序员呢？他大概会 会举一反三的思考，当前系统还会有哪些隐患，怎样杜绝这列情况的发生 甚至会深入阅读底层代码，分析核心问题所在，防患于未然。 整理文档，总结经验，并且分享给周围同事，帮助团队在代码开发上做的更好。 …… 当前系统中所有做的不好的地方，都是你值得把握住的成长机会，也是你能够超越同事的杀手锏。 任务分级吴军老师说过一个“伪工作者”的概念：在Google内，上述这种每天应付事务性工作的人被称为Pseudo Worker，直译出来就是“伪工作者”。这些人每天把自己搞得很忙，他们所做的工作可能也是公司里面存在的工作，但是那些工作（也被成为伪工作）不产生什么效果。 程序员是智力密集型岗位，但很多人把它当成了劳动密集型岗位。作为一名有了一定工作经验的程序员，我想你一定不会满足于CURD的开发的，然而必须承认的是，公司项目的80%的代码都是业务开发。 程序员都是讨厌重复的，要学会抵制重复和简单任务的诱惑，它们对你的成长毫无帮助，千万不要把自己陷入这种”麻木的充实”当中。如果只是满足于这些日常开发任务，久而久之，便会逐渐失去竞争力，被更年轻的程序员所替代。 要让自己保持竞争力，就要在公司里主动承担更有影响力的工作，学会安排当前工作中的优先级，重点关注那些更有价值，更能提高开发效率的工作。即使这些工作会让你感到困难，但一旦把握住了，这就是获得成长的机会。 公司与个人我曾经在某个求职app上，专门看员工对他们公司的评价。我发现一个现象，无论是什么样的公司，下面的评论里90%都是负面的。 我自己也有这样的经历，只要在一个公司待久了，就会发现有很多不尽人意的地方，有种“不配自己”的感觉，想着到更牛逼的地方去。 毕竟如果公司没有完善的培养体系，或者浓厚的技术氛围，你的工作逐渐激情是下降的，你能学到的东西也是边际效应递减的。 但是，以上指针对一般的程序员，作为一名出色的程序员，应该有着强烈的自驱力。 公司的项目中带给你的成长是有限的，不要指望能从公司的项目经验中得到提升，大部分的提升还是在于自学、系统性的学习，以及不断的追问，和持续的输出。 功夫都在课外，如果那你认为程序员是智力密集型岗位，那就应该知道，公司支付给你的薪水可不只是上班的8小时，你在业余也必须要求自己不断精进，让自己的技术配的上市场的发展水平。 另外，你也可以把公司的项目当做自己的试炼场，毕竟这占据了我们绝大多数时间，与其只是完成功能需求，不如把自己新学到的只是技能给应用起来，创造更多的收益。这对自己和公司来说是双赢。 “不要总想着国家为你做什么，而要想你为国家做了什么。”——肯尼迪 关系转换写到这里，可以发现，在工作中化被动为主动是多么重要的一件事，毕竟我们每天算上出勤，有一大半时间都花在工作上，如果不把工作的目的性加强，任由时间流逝是一件多么可惜的事情，尤其是在年轻时宝贵的黄金时间。 我在读陈海贤老师的《自我发展心理学》时学到一点，用关系的视角看问题。 没有人是一座孤岛，人总是生活在关系中。我们能在关系中扮演很多角色，我们的自我就有很多可能性。如果我们总是把自己固定在某个角色中，把这个角色规定的言行举止当作自己的个性，久而久之，我们就忘了自己还有的其他可能性，而我们的自我也很难有进一步的改变和发展。反之，如果我们能尝试很多不同的角色，发现自己的更多面，自我就能得到更好的发展。 所以，如果你只是把自己当成公司的螺丝钉，那你就只能干螺丝钉的活，你把自己认定在这个角色上，也就失去了别的发展的可能。 如果你调整了角色，比如站在项目负责人的视角看问题，或者站在领导的视角看问题，你就会多出很多思路和解决方案，你发现自己能去做的事情也就多了，动力也更足了。 这一思路还可用在你和同事之间，如果你只是满足于分内的工作，那永远只是低层次的码农，而如果你站在团队视角，多去思考如何才能提高团队的代码能力，或者提高小组内的技术氛围，比如主动的输出和分享等等，你就会这些新的角色上发现更多成长的可能性。这其实也是一种利他思维的体现，会使你获得同事们的信赖和帮助，以及提高自己在同事心目中的形象。 买家竞争关于996的话题讨论也很热，揭示了工人和老板的矛盾，但我想换一个视角看这个问题。 从经济学的角度看，买家和卖家之间从来是不竞争的，竞争永远发生在买家和买家之间，或者卖家和卖家之间。 公司的出现，永远只是给你多一份选择，而作为程序员，我们与周围程序员的竞争，比起和老板间的对抗，会更为激烈。 一家公司可能不会持续很久，但你的简历会陪伴你很久，每个人都在为自己的简历打工，想要脱颖而出，就要比同行做的更好，在市场上获得更高的议价能力。 另外，一般越容易996的地方，也是资本越密集的地方，也会愿意支付更多的劳动成本。 想明白这些，我想，程序员该朝什么方向去努力就不用多说了吧。 积累技术广度和深度如果工作多年，你还是掌握只一门语言，或者一个方向，那带给你的提升肯定是不够的。 比如我自己，工作中主要用python，但如果只是擅长python，就不满足于未来的发展了。最近也在深入学习前端和Go语言，多几把板斧，多一些竞争力。 提升深度，就要更去关注源码、性能、算法、架构、底层。如果公司没有条件帮助你提升这些，就要自己主动去学，别怕辛苦，这是获得进阶的必经之路。 目前想要面试进大厂，算法能力越来越重要，这是每一个程序员都要过的一个关卡。 leetcode刷题要养成习惯，我常常刷题有一种挫败感，然后便会放弃，这也是大多数人都会面临的窘境。其实，很多题不多做几遍，是不可能完全掌握的，那些高手都是一步一步过来的。也许做第一遍只是学习别人的思路，第二遍还是不能上手，坚持多做几遍，直到融会贯通。 学生思维16年刚毕业时，在知乎上的看到一个关于学生思维的帖子，https://www.zhihu.com/question/41365485，当时觉得触目惊心，因为里面提到的各种学生思维，比如不会反馈，不会合作，被动接受等等，我基本上全占了。 现在回看这个帖子，值得庆幸的是，这些弱点我都已经克服了。从小被应试教育荼毒颇深，花了很大的精力才把身上的这些弊病给净化，从而获得了宝贵的成长型心态。相信亡羊补牢为时未晚，此刻正在正确的轨道上策马扬鞭。 如果你作为一个工作三年的程序员，依然身上还保留着许多学生思维，那可真是贻笑大方了。 工作三年VS读研三年这也是一个很经典的讨论了，我的观点是，两边都可以列举很多优缺点，但完全不在一个维度上对比，没啥意义。 更有可比性的方式是，毕业三年的你，是否已经比同样毕业三年的程序员优秀。 比如，可以翻看市场上招聘岗位上对毕业1年，3年，5年的程序员的不同标准，你真的达到了吗？如果发现自己工作几年跟刚开始工作的小白没什么优势，那可就要小心了。 我之所以特地把这个拿出来讨论，是因为社会是很残酷的，在你相应的工作年限里，究竟有没有达到相应的水准，很大程度上决定了用人单位愿不愿意要你。换句话说，在你刚开始工作的时候，竞争就已经开始了，这是一场跟自己的竞争，你必须要保证在这个赛道上的每个阶段达成相应的成绩，否则会输的很惨。 所以，本科毕业选择工作的本科生，他们不是跟同一届读研的本科生比，更不是3年后的他们跟3年后的研究生同学比，而是他们要跟当年同一届同样选择出来工作的所有研究生、博士生比。这就是现实。 重新回到上面这个讨论，如果有个应届生问我，该是选择读研或工作，我给他们的建议是：如果你决定了去工作，那就在做这个决定前，先问问自己，你究竟有没有形成能让自己在工作上快速成长的能力。 当然大部分应届生都是不懂这些的，毕竟社会和学校完全不一样。 个人品牌对于程序员来说，个人品牌就是你技术影响力的体现。 哪怕做不到github上有闪光的项目，也可以选择低成本的坚持写技术博客的方式，去总结和输出自己的观点，主动输出永远是最好的学习的方式。 木桶原理不适用于程序员，你只需要去把自己最擅长的地方去做专做精，面面俱到却哪里都不突出的半吊子不可能成功。为了一个技术梦想，为伊消得人憔悴，孜孜不倦的耕耘，并且享受着收获的喜悦，我认为这样才是一个技术人最好的状态。 此外，不能闭门造车，如果有机会，就多去参加技术大会，多做联结他人，不固步自封，不孤芳自赏，要往更高更远更深的地方飞去。 坚持+信念最后，洒一点鸡汤。 我认为成长是一个人生目标愈来愈清晰的过程，随着经历世事沧桑，浮沉跌宕，你看事情的眼光也逐渐明亮，会摒弃很多的妄念，并且变得专注，明确自己的方向。 给自己顶一个目标，无论是成为很牛的程序员，还是跳槽到更好的公司，还是提升自己的技术影响力，如果你真心有这个目标，那我相信，没有什么东西能够阻挡你，你甚至会发现全世界都会来帮你。精诚所至，金石为开。 希望大家都能成为自己想成为的人，有所追求，有所舍弃，但在已经决定追求的事情上绝不放弃。]]></content>
      <categories>
        <category>比特胶囊</category>
      </categories>
      <tags>
        <tag>职场</tag>
        <tag>编程</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DRF最佳实践的十件事]]></title>
    <url>%2F2020%2F04%2F04%2FDRF%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E7%9A%84%E5%AE%9E%E8%B7%B5%E5%8D%81%E4%BB%B6%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[讨论一下关于Django Restfule Framwork的最佳实践 翻译文章，原文地址：https://medium.com/profil-software-blog/10-things-you-need-to-know-to-effectively-use-django-rest-framework-7db7728910e0 1. ViewSetsviewsets的好处是使得你的代码保持一致，并且免于重复。如果你编写的views不止去做一件事，那么viewsets就是你想要的东西。 举例来说，如果你有一个model叫做Tag，你需要列表、创建和详情的功能，你可以定义一个viewset: 12345678910111213141516from rest_framework import mixins, permissionsfrom rest_framework.viewsets import GenericViewSetclass TagViewSet(mixins.ListModelMixin, mixins.CreateModelMixin, mixins.RetrieveModelMixin, GenericViewSet): """ The following endpoints are fully provided by mixins: * List view * Create view """ queryset = Tag.objects.all() serializer_class = TagSerializer permission_classes = (permissions.IsAuthenticated,) viewset的mixins可以被自由组合，你可以定义自己的mixins或者使用ModelViewSet。 ModelViewset可以为你提供以下方法：.list()，.retrieve(), .create(), .update(), .partial_update(), .destroy()。 此外，当你使用viewsets时，也会令你的路由配置更加的清晰。 12345678910from django.conf.urls import url, includefrom rest_framework.routers import DefaultRouterapi_router = DefaultRouter()api_router.register(r'tag', TagViewSet, 'tag')urlpatterns = [ url(r'^v1/', include(api_router.urls, namespace='v1'))] 现在，你的viewset可以帮你实现以下功能： 获取Tag列表，发送GET请求给 v1/tag/ 创建Tag，发送POST请求给 v1/tag/ 获取特定Tag，发送GET请求给v1/tag/&lt;tag_id&gt; 你甚至可以在viewset里面通过@action装饰器添加一些自定义的路由。 2. 理解不同类型的serializers作为一个DRF的使用者，你不必太去关心views或者路由配置，所以你可能会把绝大部分精力放在serializers上来。 serializers是充当Django的model及其表现形式（例如json）之间的翻译器。每一个serializer能够既被用作读也可用作写，初始化的方式决定了它将执行的动作。我们可以区分出三种不同类型的serializer: create, update, retrieve。 如果你想要在序列化器外部传输数据，下面是一个例子： 1234def retrieve(self, request, *args, **kwargs): instance = self.get_object() serializer = ProfileSerializer(instance=instance) return Response(serializer.data) 但是创建时，你需要另一种写法： 12345def create(self, request, *args, **kwargs): serializer = ProfileSerializer(data=request.data) serializer.is_valid(raise_exception=True) serializer.save() return Response(serializer.data) 最后，当你更新一个实例，你不但要提供instance，也要提供date: 123456789def update(self, request, *args, **kwargs): instance = self.get_object() serializer = ProfileSerializer( instance=instance, data=request.data ) serializer.is_valid(raise_exception=True) serializer.save() return Response(serializer.data) serializer.save()会基于初始化时的参数传递调用适当的内部方法。 3. 使用SerializerMethodFieldSerializerMethodField是一个只读的字段，通过在其附加到的serializer classs上调用相应的方法，在请求处理时计算其值。 举例来说，你有一个model，里面有一个字段datetime存储的是models.DateTimeField类型，但是你想在序列化时，获得timestamp类型的数据： 123456789101112from rest_framework import serializersclass TagSerializer(serializers.ModelSerializer): created = serializers.SerializerMethodField() class Meta: model = Tag fields = ('label', 'created') def get_created(self, obj): return round(obj.created.timestamp()) SerializerMethodField接收method_name，但是通常使用默认的命名方法会更为便捷，比如get_&lt;field_name&gt;。另外你要确保，不会为任何繁重的操作增加方法字段的负担。 4. 使用source参数很多情况下，你的model里面定义的字段，与你想要序列化的字段不一样。你可以使用source参数，轻松解决这个问题。 举个例子： 1234567from rest_framework import serializersclass TaskSerializer(serializers.ModelSerializer): job_type = serializers.CharField(source='task_type') class Meta: model = Task fields = ('job_type',) 模型中的task_type会被转换成job_type。这个操作不光适用于读，还适用于写。 另外，你还可以借助点语法去从关联的模型中获取字段。 1owner_email = serializers.CharField(source=&apos;owner.email&apos;) 5. 序列化字段的验证除了在初始化serializer字段和serializer.validate（）hook可以传递的validators参数之外，此外还有一种字段级别的验证，可以帮你为单独的每个字段定义它们自己的验证方法。 我发现它有用的原因有两个：首先，它可以对特别的字段进行校验，进行解耦。其次，它可以产生结构化的错误响应。 这种验证方式的使用，和SerializerMethodField特别相似，只是这时候的函数名字形如def validate_&lt;field_name&gt;。举个例子： 1234567891011from rest_framework import serializersclass TransactionSerializer(serializers.ModelSerializer): bid = serializers.IntegerField() def validate_bid(self, bid: int) -&gt; int: if bid &gt; self.context[&apos;request&apos;].user.available_balance: raise serializers.ValidationError( _(&apos;Bid is greater than your balance&apos;) ) return bid 如果验证错误，会得到下面这样的输出： 123&#123; &quot;bid&quot;: [&quot;Bid is greater than your balance&quot;]&#125; 验证方法必须要返回一个值，之后会传给model实例。 另外要记住，字段级别的验证将会在serializer.validate()之前被serializer.to_internal_value()调用。 6. 把值直接传给save方法某些情况下，将值从序列化器外部直接传递到其save（）方法很方便。 此方法将采用可以等同于序列化对象的参数。以这种方式传递的值将不会得到验证。它可用于强制覆盖初始数据。 123serializer = EmailSerializer(data=request.data)serializer.is_valid(raise_exception=True)serializer.save(owner_id=request.user.id) 7. 使用CurrentUserDefault如果需要设置用户，比上面的例子更好的是，使用CurrentUserDefault，这时候不必去重写view了。 123456from rest_framework import serializersclass EmailSerializer(serializers.ModelSerializer): owner = serializers.HiddenField( default=serializers.CurrentUserDefault() ) 这将会做两件事。首先，将在请求对象中认证的用户设置为默认用户。其次，因为使用了HiddenField，因此不会考虑任何传入的数据，所以不可能会设置成别的用户。 8. serializers的初始数据有时候你需要去获取serializer的最原始的数据。这是因为数据已经通过运行serializer.is_valid（）进行了修改，或者需要在validated_data尚不可用时比较验证方法中另一个字段的值。 数据能够通过serializer.initial_data被获取到，格式是dict，举个例子： 123456789101112from rest_framework import serializersclass SignupSerializer(serializers.ModelSerializer): password1 = serializers.CharField() password2 = serializers.CharField() def validate_password1(self, password1): if password1 != self.initial_data['password2']: raise serializers.ValidationError( 'Passwords do not match' ) 9. 在嵌套序列化程序中处理多个创建/更新/删除大多数时候，序列化器是完全简单的，并且有一定的经验，没有什么可能出错。但是，有一些限制。当您必须在一个高级序列化程序中支持嵌套序列化程序中的多个创建，更新和删除操作时，事情可能会有些棘手。 这需要权衡：要选择处理较多的请求数量，还是在一个请求里处理较长的时间。 默认情况下，DRF根本不支持多个更新。很难想象它如何支持所有可能的嵌套插入和删除类型。这就是DRF的创建者选择灵活性而非现成的“万能”解决方案的原因，并把特权留给了我们。 在这种情况下，可以遵循两种路径： 使用颇受欢迎的第三方库DRF Writable Nested 自己做 我建议至少选择一次第二个选项，这样您就会知道其中的含义。 在分析传入数据之后，在大多数情况下，我们可以做出以下假设： 所有应更新的实例都有ID， 所有应创建的实例都没有ID， 所有应删除的实例都都存在于数据存储（例如数据库）中，但不会出现在传入的request.data中。 基于此，我们知道如何处理列表中的特定实例。以下是详细显示此过程的代码段： 1234567891011121314151617181920212223242526272829303132333435363738394041424344class CUDNestedMixin(object): @staticmethod def cud_nested(queryset: QuerySet, data: List[Dict], serializer: Type[Serializer], context: Dict): """ Logic for handling multiple updates, creates and deletes on nested resources. :param queryset: queryset for objects existing in DB :param data: initial data to validate passed from higher level serializer to nested serializer :param serializer: nested serializer to use :param context: context passed from higher level serializer :return: N/A """ updated_ids = list() for_create = list() for item in data: item_id = item.get('id') if item_id: instance = queryset.get(id=item_id) update_serializer = serializer( instance=instance, data=item, context=context ) update_serializer.is_valid(raise_exception=True) update_serializer.save() updated_ids.append(instance.id) else: for_create.append(item) delete_queryset = queryset.exclude(id__in=updated_ids) delete_queryset.delete() create_serializer = serializer( data=for_create, many=True, context=context ) create_serializer.is_valid(raise_exception=True) create_serializer.save() 这是高级序列化程序如何利用此mixin的简化版本： 12345678910111213141516171819202122from rest_framework import serializersclass AccountSerializer(serializers.ModelSerializer, CUDNestedMixin): phone_numbers = PhoneSerializer( many=True, source='phone_set', ) class Meta: model = User fields = ('first_name', 'last_name', 'phone_numbers') def update(self, instance, validated_data): self.cud_nested( queryset=instance.phone_set.all(), data=self.initial_data['phone_numbers'], serializer=PhoneSerializer, context=self.context ) ... return instance 请记住，嵌套对象应使用initial_data而不是validated_data。 那是因为运行验证会在序列化器的每个字段上调用field.to_internal_value（），这可能会修改特定字段存储的数据（例如，通过将主键更改为模型实例）。 10. 覆盖数据以强制排序通过在view上的queryset添加排序，可以轻松地实现对列表视图的排序，但是在还应该对嵌套资源进行排序的情况下，并不是那么简单。 对于只读字段，可以在SerializerMethodField中完成，但是在必须写字段的情况下该怎么办？ 在这种情况下，可以覆盖序列化程序的data属性，如以下示例所示： 12345@propertydef data(self): data = super().data data['phone_numbers'].sort(key=lambda p: p['id']) return data 结论：希望您在本文中找到了一些有趣的新技术。有新的drf使用技巧或想法，欢迎分享！]]></content>
      <categories>
        <category>比特胶囊</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>翻译</tag>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5000字干货总结python社招面试经验]]></title>
    <url>%2F2019%2F12%2F04%2F5000%E5%AD%97%E5%B9%B2%E8%B4%A7%E6%80%BB%E7%BB%93python%E7%A4%BE%E6%8B%9B%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[即使是临近年末，我依然选择了裸辞，冒着可能会失业的风险。 花了一周多一点的时间，在上海参加了十几家公司的面试，也包括美团、字节跳动等大厂，可是因为能力不够或技术栈不匹配被刷了。最终有三四家想要要我，我也拿到了一份较为满意的offer。 我工作三年，主要编程语言是python，找的是后端开发或运维开发的岗位，想结合自己的实际面试经历，来谈一谈python社招的一些经验，欢迎大家交流讨论~ 即使是临近年末，我依然选择了裸辞，冒着可能会失业的风险。 我之前是在深圳工作的，因为自己是江苏人，也不想在深圳长期发展，所以先辞了职，回到上海这边好让自己更方便的参加面试。 这是我第二次裸辞了，有了上一次的裸辞经验，我这一次在心理准备方面，明显更加的游刃有余。 花了一周多一点的时间，在上海参加了十几家公司的面试，也包括美团、字节跳动等大厂，可是因为能力不够或技术栈不匹配被刷了。最终有三四家想要要我，我也拿到了一份较为满意的offer。 面试是一个非常消耗心力的过程，我很难想象，若不是我比较侥幸，拿到了几个还满意的offer，我很难想象在此时凄风苦雨的寒冷的上海，孑然一身的我，会面临怎样的崩溃与绝望。 所以，我衷心希望，我能够把自己的一些面试经验分享出来，去帮助到一些正在找工作的朋友，让他们的求职之路更顺利一些，少一点像我这样的折腾。 我工作三年，主要编程语言是python，找的是后端开发或运维开发的岗位，想结合自己的实际面试经历，来谈一谈python社招的一些经验，欢迎大家交流讨论~ 面试之前市场环境 先说一下大环境，中国的互联网环境已经渐趋稳定成熟了，但初中级别的程序员依然很泛滥，高级程序员很缺失。所以想要在众多应聘者中脱颖而出，实力才是王道。 另外，通常的招聘季是金三银四或者金九银十，像我这个11月份去找工作的毕竟是很少了，但我觉得上海毕竟是大城市，要说市场上没有岗位是不可能的，另外在淡季，和我竞争的人也很少了。所以，基于以上的判断以及自己的勇气，我毅然觉得辞职，从深圳来到了上海。 个人定位 我觉得，每一个招聘者都要对自己在市场上的位置做一个合理的评估，这样才能准确的知道自己想要找什么类型的公司，是大公司大平台呢，还是中小型企业呢，还是创业公司呢？评估的依据，取决于自己的实力，职业道路的方向，以及对市场的认识。 不过如果不清楚也没有关系，投递公司的时候可以各类公司都投一投，大中小公司都去面一面，总之，不要把鸡蛋放在一个篮子里，多给自己制造一些机会。面试是一个很好的去接触外界，了解自己能力水平的过程，可以帮助你对市场环境有一个更清晰的认识。面试结束后通常有反问问题的环节，也可以把握住机会，多去问一问对方公司在做的东西，使用的技术栈等等。 对于我自己来说，我就把面试当成一个很好的检验自己的机会，同时让我有机会去和别的公司交流技术。所以说，平时在工作过程中，也可以隔三差五的出去面试一下，看看自己的能力水平几何，避免自己和市场脱节太久，以及温水煮青蛙的情况。 简历 接下来就是制作一份简历，关于如何制作一份简历，网络上的教程也很多了。我觉得技术简历的关键就是要把自己的做的比较出彩的项目，以及个人技术栈讲清楚，这些都是面试中问的比较频繁的几个点。另外因为自己痴迷于markdown，第一次尝试了markdown风格的简历，效果还不错，蛮清晰的。 渠道 对于招聘渠道的选择，如果有小伙伴的内推那是最好的，另外建议多注册几个app，多管齐下的去寻找面试机会，比如拉勾、boss直聘、猎聘等等。一些想去的公司的官网的招聘页，也是一个不错的信息来源。 面试准备作为技术面试，该如何去复习准备面试呢，我觉得可以从以下几点去考虑。 数据结构与算法 为什么把这一块放在第一个讲，因为这是技术面试里非常重要，但是平时工作中又最容易忽视的一块。都说「面试造航母，工作拧螺丝」，如果不是算法岗，程序员在日常工作中算法使用场景非常有限，但这就是面试考察的一个重点。 我大概面了十几家公司，基本每家公司都会考一些算法题，或者让你说一下思路，或者直接手写程序，如果没有事先准备过，会特别的不适应，尤其是白板算法那块。 所以，我的准备建议是，面试前至少前一周，就要花时间去练习算法题，保持手感了。 首先强推leetcode网站，中文站是https://leetcode-cn.com/。leetcode是非常有名的刷题网站，里面汇聚了各大企业的经典算法题，而且可以在线提交代码，自定义测试用例，查看其他人的题解等等。如果你觉得中文站上面的题解没有自己想要的，也可以看一下外文站https://leetcode.com/，他们的题目顺序都是一样的，只是中文站在本土化这方面更强一点。 如果因为时间紧迫，我建议你针对以下数据结构和算法的知识点进行重点复习： 各种排序算法，冒泡排序，堆排序，快速排序等，时间复杂度空间复杂度分析，能做到手写。 常用数据结构。链表、二叉树、堆、栈等等。 经典算法题。（待整理） 基础知识 任何一门技术面试，基础知识一定是重中之重。对于python程序员面试来说，我觉得下面三块内容比较重要，考察的频率也非常高。 语言基础 可变对象、不可变对象、装饰器、迭代器和生成器、线程和进程、魔术方法、动态解释性、元类等。 web基础 http请求、状态码、网络安全、django处理请求的顺序、cookie和session 数据库 mysql的事务、索引、锁、性能调优，nosql数据库中redis考察的比较多。 项目经验 一般对应届生来说，基础知识很重要。对于社招来说，项目经验是非常重要的一块内容。 我建议可以从下面几个角度去准备自己的项目： 项目介绍 推荐STAR模型。 S——situation，项目是什么背景下产生的T——task，你的任务是什么A——action，你怎么做的R——result，结果如何 项目中的难点、闪光点 我相信每一个真实做过自己的项目的人，肯定会对自己的项目有所思考。总结一下自己在这个项目里最难的地方，以及最精彩的地方，也可以使用上面的STAR模型。 项目框架 有的面试官会要求你在白纸上把项目的框架图或者设计图画出来，这个也可以提前准备下，做到条理清晰，临场画的话很容易乱。 总结 面试是一场艰难的战役，我发现在那种紧张对弈的交锋氛围中，我从来没有体会过所谓超常发挥的感觉，准备了100分，能把60分发挥出来就已经非常不错了。所以，建议每一个面试者都要提前把一些必问的东西（个人介绍、项目经验等等）提前准备好，并且模拟表达一下，以防临场紧张而忘词。 面试真题因为自己大厂和创业公司都会去面，给我的感觉是，大厂的考察深度会更深一点，比如问你怎么用python定位一些内存满、CPU满的问题，怎么做mysql性能优化等等。而小公司问的更多是一些基础问题，以及看你之前经验的一个匹配度。 我这里从我亲身的面试经历，精选出了30道面试常考题，涉及到了python面试的方方面面，大家可以自行测试。 python基础 python是什么样的语言，和其他语言的区别。 python中的线程和进程，以及使用场景，你知道协程吗？ GIL是什么，为什么会有GIL，去掉会怎样，有了GIL为什么还要给程序加锁？ 迭代器、可迭代对象、生成器分别是什么？生成器的作用和使用场景？ python中的装饰器是什么？如何实现？使用场景？ python中的元类是什么？ python中的可变对象和不可变对象之间的区别。 python的魔术方法你知道哪些，new，init，call的区别是什么 django的中间件是什么 celery的原理，如何配置worker的权重 项目 如何定位内存过高或CPU过高的问题 画一下你的项目的结构 项目中你遇到的最大的困难是什么，是如何解决的？ 项目中你最有成就感的地方是什么？ 你业余是怎么学习编程的？看哪些书？有自己做过什么项目？ web HTTP/GET/POST/PUT/PATCH之间的区别 状态码的含义以及出现场景，301，302，404，500，502，504等 cookie和session的区别和联系 从url请求到返回，中间经历了什么 HTTP和HTTPS的区别，HTTPS如何进行加密的 数据库 mysql的索引是什么，如何建立索引，B+树的结构 mysql中的事务是什么，隔离等级是什么 如何优化sql语句 mysql的性能优化等 操作系统 堆和栈的区别 什么是io多路复用 nginx的配置 算法 找到整数列表的最大k个数，时间复杂度 输入一维数组array和n，找出和值为n的任意两个元素 常见的排序算法，时间复杂度分析 生成一个旋转矩阵 职业发展作为一个代码打工仔，对于我来说，想要成为牛逼的程序员的路还很长，一刻都不能懈怠。 我无法从HR角度，或者技术leader的角度来臆测哪种状态的面试更能获取面试官青睐。但通过我积攒的大量的面试经验，我多少可以推断一些成为有竞争力的程序员的一些必要条件。 1. 技术是王道 这一点毋庸置疑。我是一个非科班出身的程序员，在技术成长方面更多的是在工作中学，但这还远远不够，每一位想要成为大牛的程序员，都必须深入底层原理去学习，比如操作系统、网络、数据结构和算法等，也许这些东西在你工作中看起来没用，却是提高你的技术深度，扩大技术视野的非常重要的一环。 我是一个比较容易自卑的人，在面试的时候，遇到答不上来的问题还是非常容易挫败的，觉得自己好弱。术业有专攻是一方面，但很多基础的东西是一个程序员的基本素养，在这上面丢分还是很容易给面试官造成一个不好的印象的。另外，面试所覆盖的点也不一定完全击中你所准备的东西，我觉得面试者可以在面试过程中主动「推销」自己，哪怕一个问题没答上来，也要尽可能的展现一下自己在这一块内容里做过哪些研究，避免面试官错误预估你的水平。 除了基础知识和底层原理，技术的另一块内容就是你在工作中的实践了。我在工作中常常见到一类人，他们只满足于被分配的任务，抱着多一事不如少一事的观念，不去把一个问题深入的去弄明白，害怕技术挑战，包括我自己曾经也是这一类人。 其实这样对职业发展的道路是非常不好的，如果不去走出舒适区，你永远只是一个CURD的程序员，完全没有市场竞争力。在面试中最能展现自己的，就是你在面对技术难题的时候，是如何研究，如何思考，如何解决的。所以，工作中遇到技术难题，一定要把它当做技术上的试金石，成长的宝贵的机会，而不要当做拦路虎而逃避。 2. 工作经历 面试官常会问的一个问题是，你未来的职业规划是什么。我不知道其他人有没有清晰的规划，对我自己来讲，更多的还是走一步看一步，并没有想的特别远，这其实是很不好的。 曾经有一个面试官对我讲，5年是一个关键节点，如果你工作5年，依然没有华丽的工作履历，或者工作能力仍旧处于小白水平的话，是非常危险的，市场对你的能力是由怀疑的。 我想，如果作为一个5年开发经验的人，他差不多也换了两三份工作了吧，从每一个公司的情况每一个工作岗位的内容，多少可以看出点他的职业发展路径有没有一条清晰的路线。如果一个人的目标很明确，他的每次跳槽一定有自己的内在逻辑在里面，他的技术成长也不会太差。而如果每次跳槽都很盲目，技术成长没有延续性，很可能你虽然工作很多年，但是根本没有核心的技术竞争力，这是要警惕的。 对未来的规划这块内容，我自己也非常欠缺，因为我总是抱着要「活出自我」的想法，对一些世俗理论天然排斥，其实是走了很多弯路的，不过既然我意识到了这一点，亡羊补牢为时未晚吧，未来，会多接触一些技术大牛，参加一些技术论坛，不会囿于自己的舒适区，早点找到一条快速的职业发展路径。 薛兆丰老师曾经讲过一句话，「每个人都在为自己的简历打工」，我在这里感同身受，卖方只是提供工作岗位的，竞争永远是买方和买方之间的竞争。所以，想要出人头地，一定要比其他员工多下功夫，少壮不努力，老大徒伤悲。 3. 格局 这个词是我从一个猎头朋友那儿听到的，他说在职场中，男生最重要的是格局。 我是这么理解的，只有你愿意到达什么样的高度，你才有可能成为什么样的高度的人。比如，如果你只甘心做一个工程师，那就活该当一个底层码农了，而如果你能够站在更高的维度去做一些事情，我相信你能收获很多宝贵的东西。 比如，在实际开发中，多去把一些业内的新技术引用进来，而不是仅仅满足于已经成熟的开发框架；不再仅仅去完成领导分配的任务，多站在公司或者团队的视角去看问题，多一些全局的视野；遇到问题时，不要简简单单的解决了就完事了，要学会深入底层，以及触类旁通，把这一类问题都解决，形成自己的思考问题的逻辑框架…… 这些东西也是我在此前的工作中缺失的，我希望我自己能够在新的工作中，多思考，多沉淀，形成自己的技术格局。 毕竟也不是初入职场的小白了，我理当给自己提出更高的要求，这也是为了在下一次的招聘过程中，能更顺利一些。 每次拿到offer之后，总会长舒一口气，觉得自己可以休息一下了。但随之而来的是，后面的入职、适应新的工作、新的工作团队，搬家找房，一个又一个的挑战接踵而至。 还不能懈怠啊，希望自己在二十一世纪一十年代能安稳下来，以最好的姿态去迎接2020年！也祝所有在找工作的朋友们早日拿到满意的offer。 最后，我建了一个github的项目，上面会持续更新我的python学习心得和面试指导，欢迎star~ https://github.com/ZhiyuSun/python-interview]]></content>
      <categories>
        <category>比特胶囊</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>职场</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊一聊程序员职业]]></title>
    <url>%2F2019%2F11%2F13%2F%E8%81%8A%E4%B8%80%E8%81%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E8%81%8C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[最近公司来了一批新人，特别有干劲，学东西也快。作为一个有着三年开发经验，25岁「高龄」的程序员，看着这些95后们逐渐登上历史舞台，不免产生了一种危机感。。。 最近公司来了一批新人，特别有干劲，学东西也快。作为一个有着三年开发经验，25岁「高龄」的程序员，看着这些95后们逐渐登上历史舞台，不免产生了一种危机感。 我常常想，和这些新人相比，我的优势在哪儿，可是思考的结果让自己很心痛。三年间我接触过后端、前端、测试、运维、产品、设计、python、web，所学博杂，但好像没有啥核心优势，总是担任着螺丝钉的角色，这样下去，我该如何保持自己的竞争力，如何去应对「35岁辞退危机」。。 虽然没有核心技术，但是我有工作经验呀，所以，想结合我三年的编程之路，从一名普通的小码农的角度，来谈一谈我对程序员这份工作的理解。本人非大牛，本文主要面向初、中级别的程序员，文章也只是一家之言，想看硬核的程序员发展之路的请绕道。 工作常识我先列举一下我对一份工作的基本观点，程序员毕竟也是一份岗位，和千千万万的岗位也一样，也拥有着一份工作的基本特征。 1. 90%的岗位都是初级岗位 网络上经常有一些对程序员的调侃，其实我们不必把程序员妖魔化，程序员本质上只是一份普通的职业而已。 所有职业都有初级、中级、高级之分，程序员也不例外。我觉得90%的岗位，一个普通人在上面呆一个月，就能熟练了。一个初级的程序员，其实并不需要很多的修炼，只要掌握一门语言20%的知识，就能应对80%的工作了。 做程序员的难点在于，你如何找到一条技术提升的路径，实现从菜鸟向高手的转型，并且加以坚持。 2. 工作的本质：出售自己的时间换取金钱 程序员为什么工资高？ 因为想要写好程序真的要投入很多时间，而且遇到项目紧急或者产品上线常常需要加班，有时候通宵也在所难免。再加上从社会的角度来看，程序员是要吃青春饭的。 从以上几点上来看，工资高就不足为奇了。 3. 凭大部分人的努力成果，还没有到拼天赋的时候 这也是一个老生常谈的话题了。 我自己有一个「地铁理论」，是我每天挤早高峰的地铁时悟到的。假设普通人平均每天的地铁通勤时间是30min，但我总能比普通人平均节省5min左右地铁时间，在列车上的通勤时间（工作时间）大家都一样，我的优势就在于进出站（业余时间）的时间。 在那段时间里，只要你不玩手机，一心想着向前，看清前方的路，选择最适合自己的路线，而不是跟着人群往前走，随波逐流，你基本就已经超过绝大多数的人了。 4. 兴趣爱好≠工作 一些初涉职场的人，经常会抱有这种想法，希望找到一份自己既感兴趣，又很擅长的工作，最好还能高薪。 我个人一开始也是这种想法，不过后来就慢慢开悟了。对于绝大多数普通人来说，把个人兴趣和工作绑定在一起，简直就是天方夜谭。 一方面，你真的明白自己的兴趣爱好是什么吗。另一方面，工作是对人类有强烈的内耗和异化作用的，把兴趣爱好当做工作，有可能会毁了你的兴趣爱好。 那既然工作不跟兴趣爱好挂钩，我们该如何做好一份工作呢？我觉得不是兴趣爱好，而是职业精神，详见第5点。 5. 「做事」往往比「天赋」更重要 一些计算机毕业的学生，往往在程序员的职场初期有着天然优势，就是比非科班的要高贵很多。 但是天赋真的是做好一项工作的关键吗？ 第一点我就说了，其实绝大多数初级岗位工作，对于能力的要求是很低的。能胜任岗位的人很多，但真正能把事情做好做成做完美的人，很少。 举例来说，实现一个简单的开发需求，相信很多应届生刚毕业就能做了。但是，他能不能做到准时交付不延期，能不能很好的和团队进行协作，能不能在代码上精益求精，能不能考虑到产品迭代的可维护性，能不能对代码进行详尽的测试，能不能从开发中意识到自己的短板再去弥补，能不能在产品交付后去思考我该怎样去才能做的更好……这些往往和程序员天赋没有关系。 我自己总结了能「做事」的人的三个特点：靠谱、热情、责任心。我觉得只要有这三样，除非是面对那种特别高精尖的工作，单单是对普通的工作而言，哪怕你做不到满分，你也能保底做到80分。 编程金线刚才对一份工作的基本常识就谈了很久，接下来终于要深入程序员的角色了。 「编程金线」是我从冯唐老师那里得到的启发。我觉得在编程领域也有一条金线，程序员达到了就是达到了，没达到就是没达到，对于门外人，若隐若现，对于明眼人，一清二楚，洞若观火。 但是相比虚无缥缈的文字金线，我这里还有两个好消息。 第一，编程金线是可以量化的。 至于什么是好的代码，简单来讲，设计精妙，逻辑严谨。 每种语言都有各自的特点，比如著名的python之禅： 1234567Beautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.…… 在我的职业生涯中，我也经历了从写的代码风格凌乱到逐渐优雅的过程，期间离不开对优秀代码的钻研和我不断地踩坑。有时候，看到一段好的代码，是真的令人赏心悦目啊，而阅读差的代码，简直会让你怀疑人生。 当然，除了语言本身，你还应该关注整个系统的稳定性、可靠性、可扩展性等等。一段好的程序就是一件艺术品，它的上升空间是无穷无尽的，这也使得程序员这份职业有了匠人的特征。 第二，编程金线是可以通过10000小时的刻意练习去够到的。 这一点也不多说了，都是非常常见的理论，要注意10000小时和刻意练习缺一不可。 如果缺少了刻意练习，你只是一直在重复性的工作。 如果缺少了10000小时，你还没真正体会到程序员的职人匠心。 手上有血「手上有血」出自和菜头的一篇文章，我对里面的一段文字印象很深。 和菜头说，他在看履历表的时候，他不会看那些高高挂着的形容词，而是更看重这个人有没有在业余时间里做自己的专业。凡是会这么做的人，是真的喜欢这件事情，哪怕之前做的活儿很一般，未来却不可限量，因为他不怕把手弄脏。 「只要手上有血，意味着一个人之前已经背负过希望和失望，知道成败之间需要的究竟是什么。在他那里，就不会有太多不切实际的幻想，更不会用言辞把这些想法包装起来以获取他人的信任。」 如果说第一部分「基本常识」谈了我对一份工作的初级认识，「编程金线」讲了如何从新手变成高手，那么这里我就要讲如何从高手变成大师了。 但可惜的是，这块内容我没啥发言权，自己连高手都算不上，勉强算一个熟手吧，离大师的路还十万八千里。我想要表达的是，想要成为大师级别的程序员，一定要有「手上有血」的精神，这时候，程序员对它来说不是一份简单的工作，更像是一份人生使命。 我们知道，程序员下限很一般，但是它的上限是真的非常高。从这一点上说，如果你真的愿意在编程之路上上下求索，似乎「35岁辞退危机」也迎刃而解了。 洋洋洒洒写了这么多，其实还是写了不少空话的，毕竟自己不是特别硬核的程序员，也不敢大放厥词，所以不知道写的文字对大家有没有帮助。工作三年，我最近也感到了很多危机感，长江后浪推前浪，一定要再加把劲💪。 最后，有不同意见或想法，欢迎讨论~]]></content>
      <categories>
        <category>比特胶囊</category>
      </categories>
      <tags>
        <tag>职场</tag>
        <tag>编程</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[致高考学子们]]></title>
    <url>%2F2019%2F06%2F09%2F%E8%87%B4%E9%AB%98%E8%80%83%E5%AD%A6%E5%AD%90%E4%BB%AC%2F</url>
    <content type="text"><![CDATA[7年前的此刻，我正在江苏的某教室里做语文试题，开启了整个高考生涯的最后一场战役。 对于早已经通过自主招生被理想的大学提前录取的我，面对高考，自然没什么压力。 我算是没有真正经历过高考地狱的人吧。我觉得自己是幸运的，因为高考实在是太残酷了。但同时我觉得自己也是不幸的，因为没有经历过这名为“高考”的成长洗礼。 我真心觉得，此刻在考场里为了改变命运在奋笔疾书的你们，都是勇士。 虽然我的高考已经过去7年，但是似乎教育制度没有发生太大变化，象牙塔依然是象牙塔，只是外面的世界一直在风云变幻。所以我想，我下面的一些话还是能够给到你们一些启发的，以一个大学四年，工作三年的过来人的视角。 关于考试寒窗苦读12年，最后的命运却由一场考试决定。 这就是高考残酷的地方，不论你此前多么努力优秀，不到最后一刻，依然不能掉以轻心。 我一直很反感应试教育，我觉得这是对人性的剥夺。 但很多时候，我们却不得不这么做，家长很无奈，老师很无奈，为了顺应制度，我们只能服从。 我在高中时代座右铭是，“一分耕耘，一分收获”，我知道每一分的来之不易，希望自己戒骄戒躁，不靠运气，用实力来挣得每一分。 也希望你们都能在考场上发挥出最佳水平，无愧于自己十二年来的努力。 说到底，高考只是一场考试，是人生中的一个小坎。未来，你面临的挑战比高考大的多。 高考考的好，顶多是上了一个好大学，但人生是场马拉松，后面的路还很长。 人生是由无数的选择和机遇构成，没有一马平川的人生，有风有浪有故事，人生才精彩。 如果你没有发挥好，不用太在意，未来依然有机会实现弯道超车。 如果你发挥的很出色，那恭喜你，你为自己增加了人生筹码，你拥有了更多的人生选择权。 关于大学不知道你们是不是和我一样，也相信高中班主任的话：高中好好努力，到了大学就轻松了。 我当时就天真的信了这句话，结果大学过得很惨。 玩了四年，一无所获，被同辈的小伙伴们甩下了很远，毕业后才醒悟却为时已晚，错过了最宝贵的学习时光，还没做好准备，就要面对未来接踵而至的无尽挑战。 所以，不要听信那个谎言，还是那句话，高考只是人生中的一个小坎，他是一个成长的洗礼，你从此打开了一个花花世界，离开了应试教育模式，开始在无限人生可能性中进行探索。 大学给我的回忆是美好的，毕业三年，我依然怀念129的歌声飞扬、北区的食堂、3108的讲堂，和光华楼门前的大黄。好想重回校园，可惜人生无法逆流。 如果让我用一个词来概括大学的意义，我觉得那必须是“求索”。进入了大学，就好像进入了一片灿烂的星空，无数的大师如星辰般指引着我们前进，同学们如星辰般交相辉映。无论是社会实践，还是学术探究，还是学术活动，不同于高考前单一的考试标准，我们可以尽情的去探索世界，以及探索自己。 大学对我来说，最大的帮助是让我看到了无限的可能性。虽然自己一事无成，但是我看到了人生的不同活法，当时同行的小伙伴，有的醉心学术，即将赴剑桥读博士，有的毕业进入了大公司，成为了中流砥柱，还有的，半路转行，找到了自己的满意的方向。当然，更多的还是像我一样的普通人，在平凡的岗位上努力做着不平凡的事情。 我们各自演绎着属于我们自己的人生。 人生道路，没有对与错之分，只有适不适合自己。 关于爱情关于这一点我是比较汗颜的，活了25年，我还没有谈过恋爱。 一方面我享受着单身日子，觉得自己还是一个孩子，关于自我的探索，还有很多事情没有做完，不想因为恋爱而分身乏术。 另一方面，在如今这个时代，找到灵魂伴侣也越来越难了，每个人都是一个独立的个体，能够充分利用互联网做到自我完备，恋爱从过去的必需品也慢慢过渡到了可选品。 这里说一些老生常谈的观点吧。 要区别爱情和婚姻。爱情是理想主义的，婚姻是现实主义的，年轻的时候，尤其在大学，没有太多的拘束，不需要考虑那么多现实因素，大可以谈一场刻苦铭心的恋爱。等到工作后，现实的考量会越来越多，谈恋爱找对象，更多的该以婚姻为目的。 在爱情里，不要试图去寻找一个完美的人，因为在完美的人身边，你是多余的，完美的人不需要别人。所以，爱情不是你和一个完美的人相爱了，而是Ta爱了你之后，他才更趋完美了。爱情就是两个不完美的人，共同创造一个完美的关系。而保持爱情长久的一个办法，就是要尽可能保持你们在精神上同步而行。 关于工作关于工作，我非常提倡胡适老师在一篇文章里讲的三个点。 第一是要时时寻找一两个值得研究的问题。所谓“为知识而求知识”，时刻保持好奇心和求学的热心。 二是多发展一些非职业的兴趣，毕业后的第一份工作往往不是你真心喜欢的，或者是和你性情不相近的。这种情况下，为糊口而做那种非“性之所近而力之所能勉”的工作，就很难保持求知的兴趣的生活的理想主义，最好的救济方法只有多多发展职业以外的正当兴趣与活动。想要生活不苦痛不堕落，就要多方面发展业余的兴趣，使精神有所寄托。 第三个方法是，你得有一点信心。胡适所在的时代是不幸的，然而当今的互联网时代充满着无数的机遇和可能性，更应该对未来充满信心。 有个词叫“功不唐捐”，意思是没有一点努力会白白丢掉。人生每一步都会算数，希望我们都能珍惜好青春日子，努力奋斗，谁也不希望在回忆往事的时候空留遗憾。 关于人生我觉得关于上文提到的“高中好好学习，大学后就可以玩了”这样的言论简直是误人子弟。 如果把它改一下，我想改成： 人生是困难重重的，没有哪一段人生是可以轻轻松松度过的。对高中生们来说，我们努力学习，不单单是为了在高考时取得好成绩，而是锻炼我们战胜困难的能力。毕竟年轻时候，失败成本还比较低，高考时你们最大的敌人，而一旦进入社会，你会更加谨慎，再也不能随便失败了。 所以趁着年轻，勇敢的试错，不惧风险，这是你最大的资本。 无论是高考，大学，还是工作，我们所有的努力，都是在增加自己的人生筹码，让自己未来的路走的更加顺利，选择权更多。 祝考场上的你，能交出满意的答卷。 祝人生道路上的你，永远保持少年模样，不忘初心，砥砺前行。]]></content>
      <categories>
        <category>光阴的故事</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>人生</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[裸辞是一种怎样的体验]]></title>
    <url>%2F2019%2F06%2F09%2F%E8%A3%B8%E8%BE%9E%E6%98%AF%E4%B8%80%E7%A7%8D%E6%80%8E%E6%A0%B7%E7%9A%84%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[2019年5月14日，我正式入职心仪的新公司，也意味着我从2018年11月23日以来，长达172天的，接近半年的，裸辞后的空窗期，正式宣告结束了。 谈到这段裸辞经历，我觉得这不仅仅是一段简简单单的破除职业迷茫的故事，更是一份时光赐予我的礼物，它让我找到了自我，让我不再迷茫，让我更有力量去搏击人生。 我的将分四个阶段去讲述我的裸辞生涯裸辞：裸辞前，裸辞后，结束裸辞前，结束裸辞后。 裸辞前我是一名程序员。 16年7月，本科毕业后来深圳工作，满怀壮志，梦想着创造出一片天地。 没想到在的一年之后，激情便开始消退，每天开始重复工作，人也变得麻木，浑浑噩噩，没有目标。 我开始审问自己：我真的适合做程序员吗，这样下去我该怎么办。 因为公司的环境相对宽松，日子过得像温水煮青蛙，虽然在17年就有了辞职的念头，但迟迟没有行动。 记得电影《无问西东》里有这么一个故事： 民国时期的吴岭澜文科成绩第一，物理成绩确榜上无名，老师劝其转文科，他迷茫不决：“因为最好的学生都念实科”。 时任清华校长的梅贻琦对他说：“人把自己置身于忙碌中，有一种麻木的踏实，但丧失了真实。” 吴岭澜问：“什么是真实？” 梅校长答：“你看到什么，听到什么，做什么，和谁在一起，有一种从心灵深处满溢出来的不懊悔也不羞耻的平和与喜悦。” 梅校长的话对我来说有如当头棒喝，我此刻的工作状态，不就是一种“麻木的踏实”吗，我渴望真实，渴望那种“从心灵深处满溢出来的不懊悔也不羞耻的平和与喜悦”，这种感觉，我已经太久太久没有体会到了。 再后来，我又看了电影《搏击俱乐部》，里面的“self-destruction”疗法给了我很多勇气：It’s only after we’ve lost everything that we’re free to do anything. 一年后，2018年行将就木，我觉得不得不做出决定了，辞职已经是板上钉钉的事，不破不立。 我选择了裸辞，因为我知道现在的状态很差，即使入职下一家公司，也不可能保证工作的激情。 我想暂时忘记工作，希望在一段安静的时光里好好思考未来的路。 我还年轻，年轻就意味着可能性，我不想早早地把这份可能性给扼杀，而陷入买车买房升职加薪等世俗逻辑。 我觉得每个年轻人都不应该被世俗绑架，都要努力去走出属于自己的道路。 我想是在自己身上做了一场实验，看下当远离工作的我是否能创造出奇迹。 我储备了三个月的薪水，这些钱大概能让我在深圳无压力生活半年。 2018年10月24日，程序员日，在这个有着特殊意义的一天，我向领导提出了辞职。 裸辞后一个月的交接期，我奋战到了最后一刻，坚持在站好最后一班岗，跟公司和平分手。 2018年11月23日，我回收了工牌，最后一次迈出了公司的大门。 “仰天大笑出门去，我辈岂是蓬蒿人。” 此时我的步伐无比轻盈，我知道我终于冲破了桎梏，开始迈向新的人生。 辞职后，我并没有停下脚步。我知道裸辞代价很高，这段自由时光来之不易。 我必须要好裸辞后的空窗期，去完成以下事情的探索：我是谁，我想成为谁，我该怎么做。 职业生涯理论说，好的职位是兴趣、能力和社会需求的结合点。 如今事后总结来看，我的空窗期大体就是按照这三个关键词执行的。 裸辞后的故事可分为三个阶段。 第一阶段，自由探索时期（12月——1月） 这段时间，我想暂时忘掉工作，忘掉程序。 我想动用身边一切所能找到的资源，去探索，去尝试，去拓展疆界，去发现本心。 于是，在18年的最后一个月，我发疯似地去体验不一样的生活。 深圳的大小展览，交流活动，课程讲座，只要是对我有帮助的，都一场不落地去参加；我开始学摄影，学画画，逛书店，尝试之前没有做过的事；我找到许久未见的朋友，与他们畅聊人生，去解锁别人的人生密码…… 特别要说一下深圳的诚品生活，它真的帮助了我很多。 12月份开业后，我就成了那里的常客。诚品生活会举办很多大师讲座和文创讲座，我从那里汲取了很多力量。 比如，梁文道老师在主题为“何遣有涯之生”的讲座说，他感受到了社会上越来越迷茫的虚无感，他主张年轻人在工作之外，找到能够发挥自己潜力的事情，从而对抗这份虚无。 再比如，诚品生活的各类文创讲座，让我看到了在AI肆虐的今天，关于人性、情感、温度、创造以及爱的价值。 余不一一。 总之，在经历了一系列个人探索之后，如果不考虑所有的现实因素选一份dream job，我想成为一名设计师。 第二阶段，能力培养时期（1月——3月） 在第一阶段确立好目标之后，我开始朝这个去努力。 我选择了设计师领域里我最熟悉的UI设计作为岗位切入，开始调动身边的一切资源去了解这个行业，去学习相关技能。 那段时间呆的最多的地方就是宝安图书馆了，很喜欢那里的自修室，有种梦回大学的感觉。 其实不光是图书馆，城市为我们提供了诸多便利，只是我们在工作的时候，没有好好去享用他们罢了。 临近三月，我开始嗅到了春招的气息，要开始投简历了。 可是我发现，其实UI设计的初级市场已经饱和了，我丝毫没有竞争力，我也不可能利用短短两个月就成为一名设计师。 另外我的资金告急，我必须选择一条更切合实际的路。 于是就来到了第三阶段。 第三阶段，社会接轨时期（3月——5月） 事实上，兴趣和工作是可以分开的，如果把兴趣当做工作，往往会毁了你的兴趣。 设计为我打开了新的世界，我把它作为自己的爱好，用来填充工作之外的虚无感。 在选择工作方面，我还是要现实一点。我梳理了目前手上的筹码，希望结合自己的爱好和优势来选择未来的工作。 于是，我选择了前端。你可以粗浅的认为，这份工作是程序员+设计师，一个维系了上下游的岗位。 当我找到了这个答案，我的世界仿佛明亮了起来。 这是一个真正的兴趣+能力+社会需求的结合点。 3月份起，我就开始了漫长的前端学习之旅，并且结合招聘网站上的岗位介绍，对知识盲点查漏补缺。 3月末，我觉得是时候投递出第一份简历了。 结束裸辞前在寻找到自我，培养好能力后，我整个人已经焕然一新，浑身充满了力量，走路带风，目光如炬。 我将开启我的求职之旅，记得上一次海投简历还是三年前校招的时候。 不过，我还是低估了社招的难度，我的求职过程异常艰难。 从人的角度说，深圳的前端工程师的初级市场已经饱和了，而我作为一个从后端转前端的程序员，缺乏实战项目也成了我的个人劣势。 从企业的角度说，社招主要是缺人招人，很少有公司愿意招一个小白进去培养的，而且今年恰好碰上了互联网寒冬，放出来的岗位甚少。 此外，面试是一个很累的过程，尤其是对于裸辞的同学来说，他们已经与社会脱离太久了，频繁的面试失利或许会打击自信心，面临崩溃。 不过还好，我的努力稳住了这一切。 短短一个半月，我几乎跑遍了深圳所有的写字楼。 面了20多家公司，拿了5份offer。 这段时间里，我学会了如何高度自律，如何高效学习，如何反馈总结，如何正确沟通，如何保持心态……总之，裸辞期间的求职经历，把我训练成了一个怪物。 已经五月份了，金三银四招聘季已过，再往后也很难有更多好的机会了。 我知道我的裸辞生涯就要结束了，该做决定了。 结束裸辞后2019年5月14日，我正式入职了心仪的岗位，成为了一名前端工程师。 我属于闪电入职，从一面二面到签offer进入公司只花了三天。 我想这也是裸辞的好处，不必要去理会那些繁琐的离职手续和漫长的交接期。 认识了新的同事，参与了新的项目，一切都是那么新奇。 我很喜欢目前的工作，很庆幸自己，没有在面试最累的时候选择将就，而是坚持面试，等到了这家公司的出现。 也许你会说，我绕了一圈怎么还是一名程序员，裸辞的意义到底是什么呢？ 我在裸辞之前，也早已料到，也许未来我还是一名程序员。但我相信，在经历了那么多后，此时我的心境一定和过去的我不一样了，有些事情是只有你真正尝试后才能感受到的，即便会因此撞了南墙。 如今，我更加认同了自己的程序员身份，并且在工作之外拥有了去抵抗人生虚无感的能力。 我因为迷茫而选择了裸辞，未来，我也许会再次陷入迷茫。但我想，此时的我，已然拥有了战胜迷茫的力量。 另外，裸辞期间，我对自己的认知，我的能力积累，我的做事方法，我的坚持与韧性，这些都成了我不可多得的财富。 我觉得我未来不会再裸辞了，毕竟这是一件代价很高的行为，一次已经够你折腾了。 而且，裸辞只是解决问题的最极端的手段，事实上还有很多手段可以帮你破除迷茫，只是当时的我太过麻木，只得出此下策。 当然，我知道，裸辞只是人生成长中的一个小插曲，未来所面临的挑战，远比裸辞要大很多。 最后， 祝福所有人在职业道路上都能事事顺心。 祝愿所有人都能被世界温柔以待！]]></content>
      <categories>
        <category>人在江湖</category>
      </categories>
      <tags>
        <tag>职场</tag>
        <tag>梦想</tag>
        <tag>裸辞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[你好，这里是我的个人站点——“知鱼之乐” 我热爱写作，我将在这里分享我的成长感悟、技术总结、书评影评 希望我的文字能够对你有所启发或帮助 欢迎加微信交流：wx-sunxiaoyu]]></content>
  </entry>
</search>
